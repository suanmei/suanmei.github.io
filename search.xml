<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[回流与重绘及优化]]></title>
      <url>%2F2017%2F02%2F13%2Freflow-repaint%2F</url>
      <content type="text"><![CDATA[前文 《从输入url到浏览器显示页面，发生了什么？（浏览器渲染篇）》 中讲到了，页面需要根据 Render Tree 来进行布局与绘制。今天我们就基于它来理解一下 回流 与 重绘。 回流与重绘 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 注意：回流必将引起重绘，而重绘不代表一定有回流。 回流何时发生：当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流： 1、添加或者删除可见的DOM元素； 2、元素位置改变； 3、元素尺寸改变——边距、填充、边框、宽度和高度 4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变； 5、页面渲染初始化； 6、浏览器窗口尺寸改变——resize事件发生时； 队列刷新从上个实例代码中可以看到几行简单的JS代码就引起了6次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句JS操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop/Left/Width/Height clientTop/Left/Width/Height width,height 请求了getComputedStyle(), 或者 IE的 currentStyle 当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。 如何减少回流、重绘减少回流、重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有： 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器） 让要操作的元素进行”离线处理”，处理完后一起更新 a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；b) 使用display:none技术，只引发两次回流和重绘；c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存 让元素脱离动画流，减少回流的Render Tree的规模]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从输入url到浏览器显示页面，发生了什么？（浏览器渲染篇）]]></title>
      <url>%2F2017%2F02%2F12%2Furl2render-part2%2F</url>
      <content type="text"><![CDATA[我们今天来了解一下浏览器工作原理，它是由呈现引擎（也就是各位道友常说的内核）来完成的。我们今天主要借助 webkit 来看一下。 渲染流程呈现引擎一开始会从网络层获取请求文档的内容，然后开始进行下面的这个流程： 我们可以看出到如下几个点： 浏览器解析HTML／CSS： 解析 HTML ，生成 DOM Tree。 解析 CSS ，生成 Style Rules（样式规则）。 Javascript 的解析主要是通过 JavaScript 解释器来进行的，不是呈现引擎的事。它主要是通过 DOM API 和 CSSOM API 来分别操作 DOM Tree 和 Style Rules。 解析完成后，浏览器引擎会通过 DOM Tree 和 Style Rules 来构造 Rendering Tree。 当文档被解析并且添加 DOM 节点时，在 DOM 节点上调用称为 attach 的方法来创建渲染器。 Rendering Tree 渲染树并不等同于 DOM Tree，因为 attach 方法会计算样式信息，一些像 head 或 display:none 的元素就没必要放在渲染树中了。 WebKit 支持的每一个 CSS 属性都可以通过 RenderStyles (所有的样式信息都存储在上面)查询。如果 DOM 节点创建了一个渲染器，那么它使用渲染器上的 setStyle 方法将该样式信息连接到该渲染器。而火狐是通过生成 规则树 和 样式上下文树 ，来进行与 DOM Tree 的匹配。最后生成 Render Tree。 计算每个 frame (元素) 的位置，进行 layout 。 呈现引擎遍历呈现树，由用户界面后端层将每个节点绘制出来。绘制的顺序是： 背景颜色 背景图片 边框 子代 轮廓 总结一下工作原理：HTML/CSS parse —&gt; Render Tree —&gt; layout —&gt; paint 。 需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕，就会开始构建呈现树和设置布局。在解析外联脚本的同时，呈现引擎会将已解析的内容显示出来。 DOM 阻塞JS 阻塞文档解析当遇到 &lt;script&gt; 标签时，会立即解析并执行脚本。如果脚本时外部的，则会立即停止解析，直到脚本下载下来之后继续解析脚本。这样做是有原因的，因为 javascript 可能会有诸如 document.write 的操作，这样的话，后续所有资源的加载都是无意义的。 JS 有 defer 属性， es5还新增了一个 async 属性。他们都可以实现异步加载，不会阻塞文档解析。他们的区别就是 async 下载完了之后会立即执行，而 defer 是在遇到 &lt;/html&gt; 才会执行（先于 DOMContentLoaded 事件）。 还有一个同样可以实现异步加载，通过 DOM 动态添加。它的执行顺序排在 defer 之后，DOMContentLoaded 事件之前。 根据上面的特性我们可以发掘出的优化js的方法有： 合理使用 defer 和 async 或者 DOM 动态添加 合并 js 文件，或者适当的内嵌，减少请求–&gt;减少请求时间–&gt;减少阻塞时间 Minify Javascript CSS 阻塞 JS如果 js 去请求 css 的信息，这个时候 css 还没加载完毕，就会导致取到的信息错误。为了防止这一点，css 会阻塞 js 的解析。谷歌做了优化，只有脚本去访问的样式会受到尚未加载解析的 css 影响时，才会禁止此脚本。 我们可以通过 media query 来进行优化。比如： &lt;link href=”something.css” rel=”stylesheet” media=”(min-width: 750px)” 这样如果小于 750px ，则不会加载该 css 。 预解析在执行脚本时，其他线程会解析剩余文档，找出并提前下载好其他资源，但是不执行。这不会更新 DOM 树，这项工作会留给主解析器来完成。 因为浏览器是有并行下载限制的，所以我们能够尽可能的减少图片等的体积，还是需要尽量减小。 总结 发送 HTTP 请求，获取 HTML 解析 HTML ，构建 DOM树 发送 HTTP 请求，获取 CSS 和 JS 和 IMG 解析 CSS 创建 RenderStyles，解析执行 JS 基于 viewport 生成布局 绘制页面 重复 2 - 6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从输入url到浏览器显示页面，发生了什么？（网络通信篇）]]></title>
      <url>%2F2017%2F02%2F11%2Furl2render-part1%2F</url>
      <content type="text"><![CDATA[这是很出名的一道题，我们分成两部分来看这道题：网络通信和浏览器渲染。本篇将只介绍网络通信，浏览器渲染留待下文。 TCP/IP 协议族计算机与网络设备要互相通信，双方就必须基本相同的规则。比如如何探测通信目标、由哪一边先发起通信、用哪种语言进行通信、硬件如何通信，所有的一切都需要有一个规则。我们把这种规则称为协议（protocol）。 需要建立规则的事务很多，每种事务都有其对应的规则（协议）。而这所有互联网相关的协议集合我们称作 TCP/IP 协议族。 TCP/IP 通信传输流TCP/IP 分为四层： 应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端则从链路层往上走。 从下面这张图我们可以看出 TCP/IP 协议族中包含着 HTTP、TCP、IP 协议，其实还有很多。我们网页从输入 URL 到浏览器能渲染这中间的通信过程就是以下图传输流进行通信的。 好了，说了这么多，我们来逐步了解一下通信过程。 通信过程 在浏览器中输入URL。 好，在这里我们有必要了解一下 URI 和 URL 的区别。 URI 全称： Uniform Resource Identifier，就是说用某种协议来表示资源的定位标识符。 URL 表示资源的位置。所以说 URL 只是 URI 的一部分。 我们再来看一下 URI 的格式。 应用层DNS进行域名解析 DNS 和 HTTP 协议一样，也处于应用层。它负责将域名解析成 IP地址 。 DNS 查询的顺序如下: 浏览器缓存 –&gt; 系统缓存 –&gt; 路由器缓存 –&gt; ISP(网络服务提供商) DNS 缓存 (第一次访问服务商 DNS 服务器查询 IP 地址时会有一个缓存) –&gt; 递归搜索 应用层客户端发送一个想看某页面的HTTP请求 HTTP 请求分为请求头和请求主体。请求主体就是客户端要发送给服务器或者服务器返回给客户端的内容，请求头包含 通信方式(POST/GET/INPUT/DELETE…)、URI、协议版本号以及请求首部方法（Accept、Cache-Control…）。 如果是响应的话，响应头就由 协议版本号、状态码、状态码原因短语以及首部方法(Set-Cookie、Allow…)组成。 传输层TCP传输报文 为了传输方便，在传输层（TCP协议）把从应用层处接收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号以及端口号（默认80）后转发给网络层。 TCP 为了确认无误地将数据送达目标处，采用了三次握手(three-way handshaking)策略。发送端想送一个带 SYN 标志的数据包给对方，接收端收到后，会穿一个带有 SYN/ACK 标志的数据包来传达确认信息。最后，发送端再回传一个带有 ACK 标志的数据包，代表 “握手” 结束。 网络层IP协议查询MAC地址进行数据包的传输 IP协议负责把各种数据包传送给对方。如果要保证确实能传输到对方，需要确定接收方的 MAC地址。IP地址 是指节点被分配到的地址，可变， MAC地址 是指网卡所属的固定地址，一般不会变。IP地址 可以和 MAC地址 通过映射表一一配对上的，而 IP 到 MAC 的解析过程则依赖于 ARP 协议，它可以根据通信方的 IP地址 反查出对应的 MAC地址。 而一般通信双方是无法直接进行通信的（除非在同一局域网），会经过多台计算机或路由器来进行中转，所以也就需要 ARP 来一路确认下一个中转站，协助数据包的传输。 链路层进行数据传输 找到对方的 MAC地址 后，就会将数据发送到链路层，通过链路层来进行数据最终传输。此时，客户端发送请求阶段结束。 服务器接收数据 接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文（发送端TCP分割数据时打上的序号就是用来还原的）。 服务器响应请求 前面说过，响应请求头包括 协议版本号、状态码、状态码原因短语以及响应首部方法。状态码分为五类： 其中常见的包括 200 OK——成功， 301 (URL)——重定向， 404 Not Found——客户请求资源找不到。 值得一提的是，目前很多网站都会有一个重定向功能，比如你省去了 www.，它会给你重定向来添加上。这也就意味着初次请求 HTML 的过程中我们需要发起两次请求。 这样做的原因在于搜索引擎会认为 www.xx.com 和 xx.com 是两个网站，从而造成网站排名下降。还有如果两个地址都有打开过，会造成多余（双倍）的浏览器缓存。 服务器返回相应文件 请求成功后，服务器会返回相应的HTML文件 接下来就到了页面的渲染阶段了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之原型]]></title>
      <url>%2F2017%2F01%2F02%2Fdeeply_understand_prototype%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数节流和函数去抖之差异[译]]]></title>
      <url>%2F2016%2F12%2F29%2FThe-Difference-Between-Throttling-and-Debouncing%2F</url>
      <content type="text"><![CDATA[原文链接：https://css-tricks.com/the-difference-between-throttling-and-debouncing/ 在我有这些疑惑的某个日子，有人指点了我。所以，我把它们放到了博客文章里以及这个网站。两者都是为了性能而限制基于DOM事件执行的Javascript的数量的方法。但是它们，是的你猜到了，不一样。 函数节流强行限制一个函数某段时间能被调用的最大次数。比如“每 100ms 最多能执行这个函数一次。”一般情况下来说，你可能会在 10 秒内调用这个函数 1000 次。如果你节流让它每 100ms 一次，这个函数最多能够执行 100 次。 (10s * 1,000) = 10,000ms10,000ms / 100ms throttling = 100 maximum calls 函数去抖强行限制，一个函数，除非在一定时间之内没有被调用过，否则不执行。比如“仅在 100ms 内函数未被调用时才执行此函数。”可能一个函数急速突发之中被调用 1000 次，在三秒之内，然后停止被调用。如果你是 100ms 去抖，这个函数只有在本次突发结束后，在 3.1s 时被调用一次。在这里突发中每次函数被调用，他都将重置被去抖的定时器。 重点是什么？这些概念的一个主要用例是某些 DOM 事件，比如滚动和调整大小。比如，如果你将一个滚动处理程序绑定到一个元素，并且将该元素向下滚动 5000px，那么你可能会看到 100 多个事件被触发。如果你的事件处理程序做了一大堆的工作（就像繁重的计算和其他的 DOM 操作），你可能会看到性能问题。如果你能够凭借经验，少执行这段程序几次，没有太多中断，从而脱身开来，这也许是值得的。 如何实现？这两种函数都被内置在 Underscore 和 Lodash 中。甚至你不想整个的使用这些库的话，你可以从它们之中将这些函数提取出来供你使用。 简单的被节流的滚动事件: 123$(&quot;body&quot;).on(&apos;scroll&apos;, _.throttle(function() &#123; // Do expensive things&#125;, 100)); 简单的去抖的调整大小: 123$(window).on(&apos;resize&apos;, _.debounce(function() &#123; // Do expensive things&#125;, 100)); 从这里开始要升级了，你可能需要使用 requestAnimationFrame 来工作，所以即使函数正被执行，浏览器也会根据它自己的理想时机来实现。这在 this Paul Lewis tutorial 一文中有提及。 Demo简单的小实例这样你们就能体会到不同了: 这里还有一个更详实的介绍：More demos!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之定时器]]></title>
      <url>%2F2016%2F12%2F28%2Fdeeply_understand_timer%2F</url>
      <content type="text"><![CDATA[前一篇文章聊单线程的时候，简要的提到了定时器的执行情况。这里我们将对其进行更多的探讨。 setTimeout 和 setInterval 的区别可能看到这个小标题大家第一时间想到的都是，setTimeout 只执行一次，而 setInterval 则是重复执行。Oh,no!我们今天当然不能讲的这么浅，我们需要谈到的是 迭代setTimeout 和 setInterval 的区别。 123456789101112131415function foo1() &#123; // statement1 setTimeout(function bar1() &#123; // statement2 &#125;, 100);&#125;function foo2() &#123; setTimeout(function bar2() &#123; // statement2 &#125;, 100); // statement1&#125; 我们思考一下，上面这段代码，同样的两个 setTimeout 在 foo1 和 foo2 中执行情况会一样吗？如果不一样，为什么？ 答案是——不一样！很简单，setTimeout 执行时机就不一样， bar1 会早于 bar2 进入任务队列。现在我们要来细细地看一下它们的执行时间相差几何。 假设任务队列为空，这是我们的理想环境，就像物理课上我们假设小木块与冰面的摩擦力为 0 。 如果继续假设 statement1 的执行时间为 50ms ，foo1 中，会于 500ms 时启动定时器，并于 120ms 时将 bar1 插入任务队列并立即被读取执行， foo2 会于 0ms 处启动定时器，但是需要 100ms 处才能被插入任务队列，此时 statement1 已经执行完了，所以可以立即读取。他们相差 50ms 。 如果假设 statement1 的执行时间为 200ms ，foo1 中，会于 200ms 时启动定时器，并于 300ms 时将 bar1 插入任务队列并立即被读取执行， foo2 会于 0ms 处启动定时器，但是需要 100ms 处才能被插入任务队列。此时 statement1 还没有执行完毕，需要继续等到，到 200ms 时可以读取任务队列中的 bar2。他们相差 100ms 。 所以我们可以得出结论，bar1 和 bar2 的执行时间相差的是 statement1执行时间 和 定时器设定时间 两者中较小的那个。 而我们使用迭代定时器的时候大多是像 foo1 那样使用，因为在进行下一次的 setTimeout 之前，我们会有一些必要的操作以及判断。而这也就代表着，两次 setTimeout 之间的间隔是 &gt;= 指定时间的。 setInterval 则不然，它不管你的回调函数里面都需要怎样的操作，它会很准时的每隔指定的时间就去向任务队列中添加任务的。 setInterval 的缺点setInterval 的定时的准确性，看似完美，实则不然。我们回顾一下上一篇文章中展示的例子，首先，如果当前队列中有相同的 setInterval 实例，则无法继续添加，也就是说，可能会造成 setInterval 的执行次数的遗漏。再者，如果 setinterval 之前被阻塞了，那么则会造成接下来的两次 setinterval 的执行间隔时间小于指定时间。 因为这两个特性，所以很多人都会建议说少用 setInterval ，改用迭代 setTimeout 。但是诚如上面我们看到的， setTimeout 也不如我们所想象的那么完美，那么我们有没有什么更好的解决方法呢？ requestAnimationFrame大多显示器的显示频率是 60HZ ，也就是每次刷新间隔 16.7ms ，如果我们使用 setTimeout/setInterval 的间隔小于 16.7ms ，这就要造成显示器重绘的堵塞压力，每隔一段时间就会丢失掉一次定时器的执行绘制。这也就是为何 setTimeout 的定时器推荐最小使用 16.7ms 。 requestAnimationFrame 及时顺应时代的浪潮而出生的，它和上面那两位最大的区别是，它的执行间隔时间是不由我们来控制的，只跟着显示器的绘制间隔走，显示器多久绘制一次，它就多久执行一次。 当然，它的妙用可不仅仅只是这些，如果同时有几个 requestAnimationFrame ，页面重绘之前，会通知浏览器把需要执行的几个函数执行一下（它们可能在不同的 requestAnimationFrame 中），执行好了之后一并绘制，而在 setTimeout 中则不行，大家排队，挨个执行然后重绘。 而且如果页面最小化了，或者被切换到其他 Tab 了， requestAnimationFrame 会暂停执行，优化资源的利用。 但是它不支持 IE9 及之前的版本哦～ 最后我们就放个实例吧。 定时器东西不多，这就讲完了，下一篇文章可以看一下定时器的一些应用～]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之单线程]]></title>
      <url>%2F2016%2F12%2F27%2Fdeeply_understand_single_thread%2F</url>
      <content type="text"><![CDATA[在 CSS3 出来以前，我们通过 setTimeout 和 setInterval 来实现动画，我们熟悉并且热衷于它们的使用，但它背后的原理却未深究。把握核心，深究问题的根本，永远是我们的核心，今天我们了解一下定时器背后的男人——单线程。 12345setTimeout(function() &#123; console.log('0');&#125;, 0);console.log('1'); 出乎意料，上面这段代码，会先输出 1，然后输出 0。（等我们掌握了单线程，也就迎刃而解了） JS的单线程一个浏览器进程，拥有很多线程，比如 GUI 渲染线程、事件触发线程、HTTP 请求线程，以及 js 引擎线程。 js 单线程就是指 js 的线程只有一条，也就是说，同一时间，只有某个任务能够执行，这段代码可能是初始化执行的代码，可能是某个元素的点击事件，也可能是 ajax 请求的回调函数。 javascript 操作几乎都是通过页面展示出来的，大多会用到 DOM 操作，设想一下，如果我有两个操作涉及到了同一个元素，而塔门又是冲突的，浏览器需要如何处理？当然，我们也可以像其他语言一样，为 javascript 设计诸如 互斥锁 或者 信号量 的机制来实现多线程的协调处理，但是这会给定位轻量级脚本语言的 javascript 带来繁杂计算量的成本。 js 线程执行的时候，会阻塞其他线程的执行。比如下面这段代码，我们会发现，浏览器不会在每一个循环里去重新渲染页面，它会等待这段 js 执行完毕，再去执行 GUI 渲染线程，当然，浏览器会进行一定的优化，所以最终我们看到的是，浏览器直接显示出 1000000，而不是 0 - 1000000 极速闪过。 1234567var span = document.getElementsByTagName('span')[0], i; for (i = 0; i &lt;= 1000000; i++) &#123; span.innerHTML = i;&#125; 上面我提到了，一个浏览器有一个进程，但是我们可爱的 Chrome 自有其可爱之处，它为了防止，因为一个页面的 js 的不好的执行影响浏览器的所有页面，所以它为每个页面开了一个进程。当然，这里我只对 Chrome 和 Firefox 进行了测试，ie 我是一直都知道的，它是整个浏览器一个进程。整个浏览器一个进程是什么意思？所有页面共用一个 js 线程，也就是，A 页面如果有一段耗时很长的代码正在执行， B 页面触发一个元素的点击事件并不会立即执行，需要等待 A 页面的 js 执行完毕。 Event Loop单线程意味着同一时间只能执行一个任务，是不是说 Javascript 是同步的？那么为什么还会有 XHR 异步请求？如果有好几个事件等着被执行，该如何安排？ js 线程上的代码是顺序执行的，是同步的。而非同步的，诸如响应事件， ajax 请求，定时器事件，它们都被放置到一个队列里面，我们称之为任务队列。 前面我们讲过，函数被调用的时候，会创建上下文，形成上下文栈，当函数返回后，其上下文会退出栈。如果栈空了，就会从任务队列中，读取排在最前面的事件并执行。 下面我们就要主要讲一讲任务队列的由来了。 身处执行栈中的代码会调用外部的各种 API ，我们拿 XMLHttpRequest 来说。JS 的执行线程发起异步请求，浏览器会开一条新的 HTTP 请求线程来执行请求，这时候 JS 的这一步任务已完成，会继续执行下面的其他任务。然后在之后的某一刻， js 的事件触发线程监听到刚才的 HTTP 请求已完成，它就会把回调函数放入任务队列中的尾部等待执行。所以，js 的单线程 和 异步 更多地应该是属于浏览器的行为。 任务队列就是由这些异步事件或者异步请求的回调函数组成的，JS 线程最后执行的异步任务，其实就是这些回调函数。 任务队列是一个先进先出（FIFO）的队列，排在前面的事件，会最先被读取执行。然后再创建执行上下文，推入栈中，依此循环往复。 借助下面的图片来看一下，仿照的 《Help, I’m stuck in an event-loop》 中的图片。 定时器setTimeout 和 setInterval 是通过定时器线程进行处理的，它会在指定时间之后将回调函数放入任务队列中。我们来看一下下面这张图（来自于《JavaScript忍者秘籍》）。 由于在 0-10ms 期间触发了 click 事件，所以事件处理函数被放置在了任务队列，并且处于任务队列最前端，但是由于当前代码还未执行完毕，所以不能立即读取执行 click 事件回调函数。10ms 的时候 setTimeout 和 setInterval 的回调函数被放置到任务队列，紧随 click 事件。 到了 18ms 的时候，js 线程的代码执行完毕，先执行任务队列最前端的 click 事件回调函数，在其执行期间，20ms 处，setInterval 第二次想要插入队列尾部，但是由于拥有相同回调函数的 setInterval 实例已经存在了，所以这次的将被废弃，不能继续插入到队列中。 在 27ms 处， click 事件结束，相应地开始执行 setTimeout 的回调函数，在其执行期间，30ms 处，setInterval 第三次想要插入队列尾部，同理，不能继续插入到队列中。 在 34ms 处， setTimeout 事件结束，相应地开始执行 setInterval 的回调函数，在其执行期间，40ms 处，setInterval 第四次想要插入队列尾部，由于这时候队列中已经没有 setInterval 的实例了，所以成功插入到队列中。 在 42ms 处， 第一个 setInterval 事件结束，相应地开始执行第二个 setInterval 的回调函数… 零延迟 setTimeout延迟时间为 0 的 setTimeout 不一定就是立即执行，这需要看当前栈是否为空，以及任务队列中在其前面是否有正在排队的任务。 我们上面所看的这段代码，就是指当前代码执行完后（等待当前栈为空），立即执行回调函数（假设任务队列中在其之前没有正在排队的任务）。 12345setTimeout(function() &#123; console.log('0');&#125;, 0);console.log('1'); 分解长耗时任务利用上面我们刚刚学习的 零延迟setTimeout 可以给我们带来一个实际的开发福利，当我们进行一个需要耗时特别久的任务时，我们应当考虑一下，用户是否能够愿意等待这么久。所以，我么需要进行一些必要的分解。 1234567var container = document.getElementById('container');for (var i = 0; i &lt; 200000; i++) &#123; var span = document.createElement('span'); span.appendChild(document.createTextNode(i)); container.appendChild(span);&#125; 这段代码创建了 200000 个DOM节点，对于浏览器来说是个挺大的负担，浏览器也需要一段时间来计算并渲染，也极有可能影响用户的交互操作。 所以我们需要做的就是把它分成几个步骤，好让后面的代码能够继续执行，也能减轻浏览器的压力。 1234567891011121314151617181920var container = document.getElementById('container'), count = 200000, devide = 5, chunkSize = count/devide, iteration = 0; setTimeout(function generate() &#123; for (var i = 0; i &lt; chunkSize; i++) &#123; var base = chunkSize * iteration; var span = document.createElement('span'); span.appendChild(document.createTextNode((i + base) + ',' + iteration)); container.appendChild(span); &#125; iteration++; if (iteration &lt; devide) &#123; setTimeout(generate, 0); &#125;&#125;, 0); 浏览器是多线程的，js 是单线程的。 异步任务的回调函数都会被添加到任务队列中，当且仅当执行栈为空时，才会读取任务队列的第一个任务。 单线程带来的是某些时候事件响应不按照我们预定的时间节点执行。 对于耗时过久的任务，我们需要将它分解成多步进行，具体分为几步，根据实际情况即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一种有趣的JavaScript内存泄漏[译]]]></title>
      <url>%2F2016%2F11%2F24%2FAn-interesting-kind-of-JavaScript-memory-leak%2F</url>
      <content type="text"><![CDATA[原文链接：http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak 最近，Avi 和 David 在 Meteor 的实时HTML模板渲染系统中跟踪了一个惊人的 JavaScript 内存泄漏。修复将在 0.6.5 版本发布（现在处于 QA 最后阶段）。 我在网上搜索关于 javascript 闭包内存泄漏的变化，网上并未提及相关事情，似乎在 JavaScript 主题下，这是一个鲜为人知的话题。（大多数你找到的谈论的是老版本IE的差劲的垃圾收集算法，但这个问题影响甚至我目前的Chrome安装！）我后来发现了一个很棒的博客，由一个V8开发人员发布在此主题上，但似乎大多数 JavaScript 使用者还不知道他们必须注意这一点。 JavaScript是一门神秘的函数式编程语言，而且他的函数就是闭包：函数对象有权访问定义在它们封闭范围内的变量，甚至在此范围已经结束的时候。一旦函数运行结束，闭包所捕获的局部变量就会被垃圾回收，所有定义在闭包范围内的函数都会自我进行垃圾回收。 现在，考虑一下这段代码： 12345678var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; theThing = &#123; longStr: new Array(1000000).join('*') &#125;;&#125;;setInterval(replaceThing, 1000); 每一秒，我么都会执行 replaceThing 函数。他用包含新分配的巨型字符串的新的对象来替换 theThing ，把 theThing 的原始值保存在了局部变量 originalThing 中。在它返回后， theThing 的旧值会被垃圾回收，包括它里面的长字符串，因为没有任何东西一直指向它。所以，这段代码用到的内存大体上是恒定的：它会一直分配大字符串，但是每一次他都会删除先前的大字符串。 但是如果我们有一个比 replaceThing 更长寿的闭包会怎么样？ 1234567891011var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); someMethod 理论上可以引用 originalThing ，所以只要 someMethod 存活着， originalThing 就应当被保留吗？这将导致无限的内存增长，因为每个版本的 theThing 都会抓住指向上一个版本的指针。 幸运的是，现代的 JavaScript 实现（包括 Chrome 和 Node 中目前的 V8 ）足够聪明，能够注意到 originalThing 在闭包 someMethod 中未被实际应用，所以它没有被放到 someMethod 的词法环境中，所以当 replaceThing 结束时，是可以对之前的 theThing 进行垃圾回收的。 （但是，等等，你可能会问！如果有人早先运行 console.log = eval ，那么看起来无害的 console.log(someMessage) 实际上是正 eval 一些引用了 originalThing 的代码？嗯， JavaScript 标准已经领先你一步了。如果你像这样偷偷摸摸地使用 eval（通过除了调用 eval 以外的任何方式），它被称为“间接 eval ”，实际上是不能访问词汇环境的！另一方面，如果 someMethod 确实包含了对使用了这个名称的 eval 的直接调用，它可能实际上访问了 originalThing ，JavaScript 环境禁止让 originalThing 一直在词法环境之外，这将导致泄露。） 好，太棒了，JavaScript保护我们免受内存泄漏之扰，对吧？好，让我们试一下另一个版本，结合了前两个例子。 123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log("hi"); &#125;; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 在谷歌开发者工具中打开 ‘Timeline’ 标签，切换到 ‘Memory’ 视图，然后点击 ‘Record’。 看起来就像我们每秒使用一个额外的兆字节！甚至点击垃圾桶图标强制手动垃圾回收也没有帮助。所以就好像我们泄漏了 longStr 。 但是这不是和以前一样的情况吗？ originalThing 仅在 replaceThing 的主体中引用，在 unused 中。 replaceThing 一结束， unused 本身（我们甚至不会运行！）就会被清理…从 replaceThing 中唯一逃脱的就是第二个闭包 someMethod 。而 someMethod 根本没有引用 originalString ！ 因此，即使任何代码都无法再次引用 originalThing ，它也从来没有被垃圾收集！为什么？是这样的，实现闭包的典型方式是每个函数对象都有一个链接，到代表它的词法作用域的字典式对象。如果 replaceThing 中定义的两个函数实际上都使用了 originalThing ，重要的是它们都获得了相同的对象，即使 originalThing 被重复分配，两个函数也共享相同的词法环境。现在，Chrome 的 V8 JavaScript引擎显然足够聪明，可以将变量放在词法环境之外，如果它们没有被任何闭包使用：这就是为什么第一个例子不泄漏。 但是一旦某个变量被任何闭包使用，它最终会出现在该作用域内所有闭包共享的词法环境中。这可能导致内存泄漏。 你可以想象一个更聪明的，可以避免这个问题的词汇环境的实现。每个闭包都可以有一本词典，里面包含着闭包实际读写的变量；这个词典中的值本身可能会是可以在多个闭包的词法环境间共享的可变单元。基于我对ECMAScript第5版标准的随意阅读，这是合法的：它对词法环境的描述将它们描述为“纯粹的规范机制，其不需要等同于任何 ECMAScript 实现的特定的伪现象”。也就是说，这个标准实际上并没有包含“垃圾”这个词，只是说了一次“内存”。（这里有一篇 关于这个问题的最佳实现的文章，虽然不是 JavaScript 主题下的。其他一些语言实现确实有效，例如Go。） 修复这种形式的内存泄漏，一旦你注意到它，是直接的，如 the fix to the Meteor bug 所示。只需添加 originalThing = null 到 replaceThing 的结尾。这样，即使名称 originalThing 仍在 someMethod的词法环境中，也不会有大的旧值的链接。 所以总结一下：如果你有一个巨大的对象在被一些闭包使用，但不是你需要持续使用的任何闭包，只要确保局部变量不再指向它，一旦你用完它了。不幸的是，这些错误可能相当微妙;如果 JavaScript 引擎不要求你必须考虑这些，它将更好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之闭包]]></title>
      <url>%2F2016%2F11%2F23%2Fdeeply_understand_closure%2F</url>
      <content type="text"><![CDATA[每写15行代码，就会遇到一个闭包。这句话毫不夸张，因为理论上来说，每一个函数都是一个闭包。 闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。 也正是由于它的特性，还有一种说法，就是： 闭包是代码块和创建该代码块的上下文中数据的结合。 词法作用域JavaScript 的作用域是词法作用域 (lexical scoping)。我们来解释一下，what’s this,顺便提一下动态作用域。 123456789101112var a = 1;function foo() &#123; console.log(a);&#125;function bar() &#123; var a = 2; foo();&#125;bar(); // 1 这就是词法作用域——在 JavaScript 中，变量的作用域是由它在源代码中所处位置决定的，并且嵌套的函数可以访问到其外层作用域中声明的变量。 词法作用域是在定义时确定的，而动态作用域是在运行时确定的。上例代码在词法作用域中输出的应该是 2 。 什么是闭包1234567var a = 1;function foo() &#123; console.log(a);&#125; foo(); // 2 我要是拿这个例子出来说，肯定要有人不同意的。‘这不是上一篇里面说的作用域链的事情吗，关闭包什么事？’ 得了您呢，咱们换个例子瞄两眼。 1234567891011function foo() &#123; var a = 1; return function() &#123; console.log(a); &#125;&#125;var bar = foo();bar(); // 1 众所周知，外部是无法访问内部作用域的内容的。那 bar 缘何可以输出 a 变量。是的，闭包！！！ 我们来看一下第二段代码，其实 bar 被声明赋值的时候，就已经绑定了上下文环境了(函数内部所引用到的变量)。 12345// bar 闭包barClosure = &#123; call: bar // 引用到function lexicalEnvironment: &#123;a: 1&#125; // 上下文环境&#125;; 闭包已经形成了，我们下一次执行的时候，自由变量就可以直接从闭包里寻找了。 第一段代码中的 foo 其实也已经产生闭包了，它绑定的是全局上下文中的自由变量。只不过没有通过 return 来进行一个返回，无法显示出闭包的特性。 共享作用域通过前面几章的学习，我们应该清楚，如果两个函数是在同一个执行上下文中，实则是共享的同一个外部作用域，两个函数里的自由变量指向的是同一个 [[scopes]] 。 123456789101112function foo() &#123; var a = 1; return &#123; increase: function() &#123; console.log(++a) &#125;, decrease: function() &#123; console.log(--a) &#125; &#125;&#125;var bar = foo();bar.increase(); // 2bar.decrease(); // 1 可以看到 bar.increase 和 bar.decrease 指向的是同一个 [[scopes]] 中的 a 。 那我现在换一换。 123456789101112function foo() &#123; var a = 1; return function() &#123; console.log(++a); &#125;&#125;var bar1 = foo();var bar2 = foo();bar1(); // 2bar2(); // 2 这个时候我门可以发现， bar1 的自由变量在第一次执行的 foo 产生的上下文中， bar2 的在第二次产生的上下文中。两者的 [[scopes]] 已经是不一样的了，所以所引用的自由变量 a 其实是不同的作用域中的，所以也就无法相互影响了。 循环中的错误这里就用 MDN 里面的例子吧。 这里之所以显示错误，原因在于三个事件响应函数（闭包）共享作用域了，这三者的 [[scopes]] 指向的是同一个 父变量对象的层级链 。 onfocus 的回调被执行时，循环已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。 解决办法就是让三个闭包有各自的执行上下文。 函数重载JavaScript 中没有函数重载，但是我门可以利用参数检测来实现伪函数重载。 123456789101112131415161718192021222324function addMethod(obj, name, fn) &#123; var old = obj[name]; console.log(old); obj[name] = function() &#123; if (fn.length === arguments.length) &#123; return fn.apply(this, arguments); &#125; else if (typeof old === "function") &#123; console.log(this.old = old); return old.apply(this, arguments); &#125; &#125;&#125;addMethod(ninjas, "find", function() &#123; // statement&#125;);addMethod(ninjas, "find", function(first) &#123; // statement&#125;);addMethod(ninjas, "find", function(first, second) &#123; // statement&#125;); 每一次执行 addMethod 添加方法的时候，都会产生新的执行上下文，同样的 fn 参数以及 old ，在每个新的执行上下文都有不同的值。这是重载能够实现的根本所在。每一个 old 的 [[scopes]] 都指向的是上一次执行 addMethod 产生的 父变量对象的层级链 。 而 this 和 arguments 则是当前函数执行时所指向的当前值。 模块我们经常使用 IIFE 来进行模块化的应用，它可以创建一个独立的作用域，也只能创建一次，我们可以在其中定义方法，除了这些方法外，其它地方都无法访问，它就是这么地简单，安全。 来看一下类库的封装吧,有两种方式。 12345(function() &#123; var jQuery = window.jQuery = function() &#123; // Initialize &#125;&#125;); 1234567var jQuery = (function() &#123; function jQuery() &#123; // Initialize &#125; return jQuery;&#125;); 他们都是通过创建独立作用域，最后会将存储了许多方法的对象暴露出去。避免了全局变量的污染，而且还提高了安全性（变量冲突）。 我们再来看一下现在的模块依赖加载器的核心概念： 1234567891011121314151617181920var MyModules = (function Manager() &#123; var modules = &#123;&#125;; function define(name, deps, impl) &#123; for (var i = 0; i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]]; &#125; modules[name] = impl.apply(impl, deps); &#125; function get(name) &#123; return modules[name]; &#125; return &#123; define: define, get: get &#125;;&#125;)(); Manager 函数只会执行一次，我们后面通过 MyModules.define 来实现模块化定义的时候，共享的同一个词汇环境，各个模块都会存储在 modules 中。而每次依赖模块执行时，都会从 modules 中取到模块整体并传递给要执行的函数。 很多时候我们在实现类库的时候会在 IIFE 前面添加上 ; ，这是由于 JavaScript 的 ASI 带来的，这也是为了防止有人不在 IIFE 后面添加 ; 从而导致代码压缩的时候出错。 替“内存泄漏”说句话很多文章，很多书里，都会讲闭包会带来 内存泄漏 ，其实正相反，闭包是来消除内存泄漏的，如果产生了，对不起，那是使用者应该背的锅。正常来说，内存泄漏 是指 IE6 带来的 bug ，现代浏览器的引用计数来进行垃圾处理，几乎不会产生 内存泄漏 。 关于 内存泄漏 ，可以看我的 一种有趣的JavaScript内存泄漏[译]。 闭包带来的妙用，远不止文中所谈的这些，这些都是用来讲解闭包的基本知识并帮助深入一点理解的。打好基础，妙用无穷，后面的学习会水到渠成。一味追求框架，不打理基础，则如高屋建瓴，慎之。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之作用域]]></title>
      <url>%2F2016%2F11%2F22%2Fdeeply_understand_scope%2F</url>
      <content type="text"><![CDATA[本来这篇文章是紧跟着 this 篇就要出来的，不想竟时隔近半年之期。从执行上下文，到作用域甚至闭包，这是一个小体系，缺了作用域以及闭包这部分，使我学习《Javascript Ninja》中设计函数式编程的的地方尤为吃力。遂补全这二章。 作用域指定了变量或者函数的可用范围 了解作用域，就是了解作用域链。 初探作用域链 当 代码执行 时，会创建变量对象的一条作用域链。作用域链的前端，是当前执行上下文的变量对象（活动对象），作用域链的下一个变量对象来自外部的上下文，再下一个变量对象来自再下一个外部环境…作用域链的尾部则是全局上下文的变量对象。 我们先来看一个栗子： 1234567891011var a = 1;function foo() &#123; var b = 2; function bar() &#123; console.log(a + b); &#125; bar();&#125; bar 的作用域链是 12345[ VO(bar), // 作用域链的前端 VO(foo), AO(global)] 作用域链其实就是将自身上下文，父上下文，一直延展到全局上下文的变量对象用一条链子连接起来的。 可能我们又要好奇了，作用域链是如何把它们串起来的呢？ 详解作用域链函数创建当函数刚创建的时候，函数就天生自带了一个属性 [[scopes]] ，它是所有父变量对象的层级链。 123456var a = 1;function foo() &#123; var b = 2; console.log(a, b); // 1, 2&#125; 当 foo 函数创建的时候，它就已经拥有 [[scopes]] 属性了。 123foo.[[scopes]] = [ gloabl.VO] 函数调用当 函数被调用 时，会创建当前函数的上下文： 12345Context = &#123; AO: &#123;...&#125;, this: thisValue， Scope: AO.concat([[scoopes]])&#125; 此时才会创建作用域链。 我们在 Javascript深入浅出之this 那一章中讲到的 变量提升 之所以存在，是因为在所有代码执行之前， js 引擎会进行一个 标识符解析 的过程。 标示符解析是一个处理过程，用来确定一个变量（或函数声明）属于哪个变量对象。 我们继续来看一个栗子： 1234567891011121314var a = 1;function foo() &#123; var b = 2; function bar() &#123; var c = 3; console.log(a + b + c); // 6 &#125; bar();&#125;foo(); 全局上下文的变量对象是： 1234globalContext.VO = &#123; a: 1, foo: &lt;reference to function&gt;&#125;; 当 foo 创建时， foo 的 [[scopes]] 属性为： 123foo.[[scopes]] = [ globalContext.VO] 当 foo 被调用时， foo 上下文的 活动对象 和 作用域链 为： 123456789fooContext.AO = &#123; b: 2, bar: &lt;reference to function&gt;&#125;fooContext.Scope = [ fooContext.AO， globalContext.VO] 当 bar 创建时， bar 的 [[scopes]] 属性为： 1234bar.[[scopes]] = [ fooContext.AO， globalContext.VO] 当 foo 被调用时， foo 上下文的 活动对象 和 作用域链 为： 123456789barContext.AO = &#123; c: 3&#125;barContext.Scope = [ barContext.AO fooContext.AO， globalContext.VO] 标识符解析结果： 1234567891011121314a-------------barContext.AO // NOT FOUNDfooContext.AO // NOT FOUNDglobalContext.VO // FOUND 1b-------------barContext.AO // NOT FOUNDfooContext.AO // FOUND 2c-------------barContext.AO // FOUND 3 我们借助 Chrome Develop Tools 看一下：（代码有很大改动） Some Cases上面的例子展示的就是闭包的 [[scopes]] 特性，这里就不赘述了。 以构造函数创建的函数12345678function foo() &#123; var a = 1; var bar = Function('console.log(a);'); bar(); // Uncaught ReferenceError: a is not defined&#125;foo(); 这里 bar 函数之所以无法解析找到 a ，是因为以构造函数创建的函数的 [[scopes]] 属性指向的是全局变量。 这个还有一个延伸，就是严格模式下，是不允许使用 with 语句的，但是如果把语句放到 new Function 中，是被允许的。 1234567891011"use strict";with(&#123;a: 2&#125;) &#123;&#125; // Uncaught SyntaxError: Strict mode code may not include a with statementfunction foo() &#123; var a = 1; var bar = Function('with(&#123;a: 2&#125;) &#123;&#125;'); // 正常 bar();&#125;foo(); new Function 产生的是 global 作用域下的函数，而且默认是 non-strict 。 延伸作用域链有两种方法，with 和 try-catch 语句。 他们都遵循：Scope = withObject|catchObject + AO|VO + [[Scope]] 。 这里拿 with 举例并且延伸一下。 12345678910var a = 1, b = 2; with(&#123;a: 10&#125;) &#123; a = b = 20; console.log(a, b); // 20, 20&#125;console.log(a, b); // 1, 20 执行 with 语句时候，作用域最前端已经是 {a: 10} 了，我们在 with 语句里面改动的 a是在 {a: 10} 中找到了，所以，全局作用域中的 a 并没有被修改。 作用域写完了，有一些边边角角的东西没写，不然展开的话篇幅太大。下篇文章就是闭包了，闭包和作用域真的是基友到爆，所以作用域一定要好好看，好好理解，多敲代码，跑到 Chrome 里去打几个断点测一测，效果会好很多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之vertical-align]]></title>
      <url>%2F2016%2F10%2F11%2Frelearn_vertical-align%2F</url>
      <content type="text"><![CDATA[我经常需要让元素在垂直方向上对齐。 CSS 提供了很多可用的方法。有时候我用 float 解决问题，有时候使用 position: absolute ，而有些时候呢，甚至通过手动添加 margin 与 padding 这样污染代码的方式来实现。 我实在不喜欢这些解决方法。浮动元素仅在顶部对齐并且需要手动清除浮动。绝对定位使得元素脱离文档流，所以它们将再也无法影响周围元素。还有，使用固定 margin 和 padding 值的话，极小的改变都会立即破坏现有的布局。 但是，这里还有另一个角色： vertical-align 。我认为它应当受到重任。好了，确切地说，使用 vertical-align 来布局是一种 hack 行为，因为它不是为此而生。它用来排列文本和文本旁边的元素。尽管如此，你还是可以在不同的上下文中用 vertical-align 来灵活地、精细地排列元素。元素的大小并不需要知晓。元素会继续在文档流中，所以其他元素可以据此改变它们的尺寸。这些优势让它成为了有价值的选择。 vertical-align 的独特性但是，某些时候 vertical-align 是个十足的混蛋，用它解决问题可能会让人沮丧，似乎有一些难以理解的规则在起作用。比如，可能会出现这样的情况，你改变了 vertical-align 属性值的的元素压根没有改变对齐方式，但同一行的其他元素却有变动。我苦恼地撕扯着头发，仍不时地陷于 vertical-align 的死角。 不幸的是，大部分有关于 vertical-align 的资料都稍显粗浅，尤其是我们想藉此进行布局的时候。它们都集中精力在这样一个误区，试图让一个元素中的所有东西垂直对齐。它们给出了这个属性的基础介绍，以及在特别简单的情况下元素如何对齐，但并未解释棘手的那部分。 因此我给自己设立了一个目标，要一劳永逸地阐述清楚 vertical-align 的行为表现，最终通过研究 W3C 组织的 CSS 规范文档 并且演练一些例子完成了。成果就是这篇文章。 所以，就让我们来讨教一下这场游戏规则吧！ 使用 vertical-align 的条件vertical-align 被用来对齐 内联级元素 ，指这些元素—— display 属性计算值为 inline inline-block inline-table（本文中不作考虑） inline 元素基本上是包裹文字的标签。 inline-block 元素人如其名：披着 inline 外套的块元素。就像它拥有 padding 、 border 、 margin 一样，它同样可以拥有 width 和 height （可能由其自身内容所决定）。 内联级元素会在各行一个挨着一个排列开来，如果当前行有太多元素放不下的时候，新的一行会在它下面产生。所有这些行都拥有一个行盒，它包裹着该行所有内容。不同大小的内容意味着行盒拥有不同的高度。在下面的插图中，行盒的顶部和底部，都以红色线条表示。 这些行盒描绘出了我们可以作用的区域。在这些行盒中， vertical-align 属性的职责是对齐一些独立的元素。 那么问题来了，元素都是相对于谁来对齐的呢？ 关于基线和外边缘垂直对齐最重要的参考点就是所涉及元素的基线，某些情况下元素的盒模型的上下边缘也很重要。就让我们来看看涉及到的各个种类的元素的基线和外边缘在哪儿。 inline 元素 这里你可以看到相连文字的三条线，行高的上下边界用红色线条，文字的高度用绿色线条，基线用蓝色线条标注出来了。左边，文字行高被设置为文字大小的高度；中间，文字行高是文字大小的两倍；右边，文字行高是文字大小的一半。 行内元素外边缘 与它行高的上下边缘对齐，如果行高小于字体的高度也无所谓，所以，在上图中外边缘是红色线条。 行内元素基线 就是字符坐着的那条线，在图中是蓝色线条。严格来说，基线就是处在文字高度中间以下的某处。好好看看 W3C 规范寻求一下详细定义 。 inline-block 元素 从左到右你可以看到三个内联块元素，左边的包含着文档流内的内容（一个‘c’），中间的除此以外还添加了 overflow: hidden ，右边的没有文档流内的内容（但内容区域还有高度）。margin 边界用红色线条标注， border 用黄色， padding 用绿色，内容区域用蓝色。每个 内联块元素的基线是用一条蓝色线条展示的。 内联块盒的外边缘 是 margin 盒的上边缘和下边缘。他们在图中是红色线条。 内联块盒的外边缘 取决于元素是否拥有文档流内的内容： 在拥有流内内容的情况下，内联块元素的基线是最后一个流内内容元素的基线，这个元素的基线根据其自身规则来计算。（左边例子） 在拥有流内内容并且 overflow 计算值不是 visible 的情况下，基线是 margin 盒的下边缘。这样，它就和内联块元素的下边缘一样了。（中间例子） 在没有拥有流内内容的情况下，基线同样是 margin 盒的下边缘。（右边例子） line box 这种标注你们在上面就已经看过了，这次我同样画了行盒中文本框的上下边界（绿色）和基线（蓝色）。我还给文本元素设了灰色背景来高亮显示它们。 行盒的上边界与最高元素的上边界对齐，下边界与最低元素的下边界对齐。上图中红线标注的框就是。 行盒的基线 是可变的： CSS 2.1没有定义行盒基线的位置. — W3C 工作组 当我们使用 vertical-align 的时候，这可能是最让人疑惑的部分了。基线会被放置在任何需要的地方，用以达成像 垂直对齐 和 最小化行盒高度 的情况。它是等式中的自由变量。 行盒的基线是不可见的，它不能立马显示出它在哪里，但是可以很轻易地让它可见。在行的开头添加一个字符，比如我在例子中添加了’x’。如果这个字符没有以任何方式对齐的话，它将默认基线对齐。 行盒中，在基线周围有一个叫做 文本框 的存在。文本框可以被简单地当成行盒中的一个没有任何对齐方式的内联盒。它的高度等于它的父元素的字体大小。因此，文本框只包含行盒的非格式化文本，它在上图中被绿色线条标注。由于文本框与基线绑定在一起，当基线移动时它也移动。（这里所说的文本框在 W3C 工作组被叫做 strut ） 喔，这就是最难的部分，通过各个角度观察我们已经知晓了所有事情。让我们赶紧总结一下最重要的事实： 这里有个叫做 line box 的区域，在这里，会有垂直对齐。它拥有一条基线，一个文本框，以及上下边界各一条。 内联级元素，是会对齐的对象。它们拥有一条基线，上下边界各一条。 vertical-align 的值上面那个列表中最后一句话提及的参考点，因为 vertical-align 而有了关联。 元素的基线与行盒的基线 baseline：元素基线正好就在行盒基线上 sub：元素基线在行盒基线下方 super：元素基线在行盒基线上方 ：元素基线根据行盒基线位置移动 line-height * &lt;percentage&gt; ：元素基线根据行盒基线位置移动绝对的长度 元素的外边界与行盒的基线 middle：元素上下边界间的中心点对齐在行盒基线加上一半x-height 元素外边界与行盒的文本框 相对于该行框的基线对齐，我们还可以列出如下这两种情况，因为文本框的位置由基准确定。 text-top：元素上边界与文本框上边界对齐 text-bottom：元素下边界与文本框下边界对齐 元素外边界与行盒外边界 top：元素上边界与行盒上边界对齐 bottom： 元素上边界与行盒下边界对齐 当然，W3C 规范中就有 正式定义 。 为何 vertical-align 如此变现呢我们可以在特定的情境下近距离观察下垂直对齐，尤其是，我们在处理某些bug的情况下。 围绕一个图标一直困扰着我的一个问题是这样的：我有一个图标，我想让他紧邻一行文字居中对齐，我给它加上了 vertical-align: middle 但似乎没有以令人满意的方式居中。来看看这个例子： 1234567891011121314&lt;!-- left mark-up --&gt;&lt;span class="icon middle"&gt;&lt;/span&gt;Centered?&lt;!-- right mark-up --&gt;&lt;span class="icon middle"&gt;&lt;/span&gt;&lt;span class="middle"&gt;Centered!&lt;/span&gt;&lt;style type="text/css"&gt; .icon &#123; display: inline-block; /* size, color, etc. */ &#125; .middle &#123; vertical-align: middle; &#125;&lt;/style&gt; 这里我再次展示一下这个例子，不过我画了一些辅助线，上面已经讲过了。 它揭示出了我们的问题的一些情况。因为左边的文字压根没有对齐，实际情况是，使用 vertical-align 我们会把盒子对齐在没有延伸（1/2 的x-height）的小写字母的中心点。所以，有延伸的字符会伸出顶部。 在右边，文字与icon都对齐于一个中点，文字的基线稍微下移，位于行盒的基线的下方。结果是很好的达到了icon与文字对齐的效果。 行盒基线的移动当我们使用 vertical-align 时，都有这样一个坑：行盒基线的位置受该行所有元素的影响。假设，一个元素以某种方式对齐了，行盒基线受影响移动了，由于大部分元素都已经根据这条基线垂直对齐完毕，最后的结果就是其他所有的元素都需要调整位置。 一些例子： 一个很高的元素，其高度占满了整个行盒，那么 vertical-align 对其是没有影响的，在它的顶部和底部之外没有空间让其移动。但是为了满足它的对齐需求，行盒的基线会发生移动，左面的高元素的取值为 text-bottom ，矮元素的取值为 baseline 。右面的高元素的取值为 text-top ，你会看到基线跳上去了。 12345678910111213141516&lt;!-- left mark-up --&gt;&lt;span class="tall-box text-bottom"&gt;&lt;/span&gt;&lt;span class="short-box"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class="tall-box text-top"&gt;&lt;/span&gt;&lt;span class="short-box"&gt;&lt;/span&gt;&lt;style type="text/css"&gt; .tall-box, .short-box &#123; display: inline-block; /* size, color, etc. */ &#125; .text-bottom &#123; vertical-align: text-bottom; &#125; .text-top &#123; vertical-align: text-top; &#125;&lt;/style&gt; 当给高元素设置 `vertical-align` 为其他值时，会有同样的表现。 甚至将 vertical-align 设置成 bottom 和 top 也会移动基线，这很奇怪，因为不该波及基线。 12345678910111213141516&lt;!-- left mark-up --&gt;&lt;span class="tall-box bottom"&gt;&lt;/span&gt;&lt;span class="short-box"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class="tall-box top"&gt;&lt;/span&gt;&lt;span class="short-box"&gt;&lt;/span&gt;&lt;style type="text/css"&gt; .tall-box, .short-box &#123; display: inline-block; /* size, color, etc. */ &#125; .bottom &#123; vertical-align: bottom; &#125; .top &#123; vertical-align: top; &#125;&lt;/style&gt; 此文为译文，现在不想翻译了，以后会把它补全，并放到译文目录下，vertical-align 章节自己会写一篇文章推上来。 就是这么任性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之line-height]]></title>
      <url>%2F2016%2F09%2F16%2Frelearn_line-height%2F</url>
      <content type="text"><![CDATA[line-height 是为数不多支持数值可以带单位可以不带单位的属性，但是其效果确实千差万别，今天会用数据来侃一侃其中的差异性。前面讲 IFC的时候说过要好好聊一聊行盒的高度，就在本文中来个大揭秘吧。 前方高能提示，第一大节全部都是原理性的研究，不想看可以略过-_-但你会后悔的，后面是实用性比较强的知识。 定义二三事行高只能算是 line-height 的中文翻译， CSS 规范 只对 line-height 作出一个稍显模糊的定义。 line-height 值（即行高）就是两行（属性一样的）文本的基线的距离 两个不同字体或者不同大小的文字，它们的基线位置各不相同，基线距离根本就不能得出 line-height 值，这也是为什么我要强调属性一样的文字。 基线解释这里又要懵逼了，什么叫做基线？我怎么知道它在哪里？ 我们小学都用过英语四线三格纸，召唤一下它，唤醒我们内涵无限的童年。相信大家一看就知道这四条线分别代表哪个部分了。 line-height 高度机制谁 ‘撑开’ 高度当我们给一个空的 div 添加任意文字时， div 的高度会从 0 变成某一个值，那 div 是由文字 ‘撑开’ 的吗？不，是line-height的作用。 看一下我对下面两个 div 设置的 style ： 123&lt;div style="font-size: 40px; line-height: 0; border: 1px solid #ccc;"&gt;font-size: 40px; line-height: 0;&lt;/div&gt;&lt;br /&gt;&lt;div style="font-size: 0; line-height: 40px; border: 1px solid #ccc;"&gt;font-size: 0; line-height: 40px;&lt;/div&gt; font-size: 40px; line-height: 0; font-size: 0; line-height: 40px; 第一个 div 虽然字很大，但是由于 line-height 为 0 ，最后落得一个高度为 0 的结果;第二个 div 虽然 font-size 为 0 字儿都显示不出来了，但是愣是让 div 高度变为了 40px 。 所以， line-height ‘撑开’ 了匿名内联盒的高度，继而 ‘撑开’ 了 div 。如果我们平时开发，遇到想设置文字垂直居中，而设置 line-height = height 时，可以把 height 去掉了，因为 line-height 完全可以替代 height 的作用。 line-height 如何 ‘撑开’我们说是 line-height ‘撑开’ 了内联盒，其实不够准确。确实与 line-height 有关，但是它更像是一个指挥关，它后面还有一套时刻运转的机制来提供服务。 这里我想强调的是，基线之间的距离只是作为 line-height 的值，不代表 line-height 是这块区域的， line-height 是没有区域之说的，它就是一个值，一个概念。 内联盒真实的区域划分就是如上图所示，内联盒真正的组成就是由内容区域以及上下半行距组成。 顶线与底线之间的区域我们叫做内容区域，内容区域只与字体及字号相关，这个知道就行。上一行文本底线与下一行文本顶线之间的距离叫做行距，这个行距应当分成两半，上一行文本的下半行距，以及下一行文本的上半行距，我在图中在它们中间留了一条缝隙以示区分。 上半行距 + 内容区域 + 下半行距 = line-height 浏览器会根据字形来确定内容区域的高度 h，然后根据 (line-height - h) / 2 来计算出上半行距和下半行距。 如果我们定义了一行文本 line-height 为 30px ，假设内容区域高度为 16px ，那 上半距 = 下半距 = (30px - 16px) / 2 = 7px 。 其实，到了现在我们可以理解，为什么我们给单行文本设置了 line-height 之后，文本会垂直居中。但是，文本其实没有真正的垂直居中。因为真正垂直居中的是内容区域，而文字在内容区域中并不是垂直居中，通过上面的图就可以发现。但这一点不需要过度计较，因为这个平时压根看不出来。 行盒的高度我们平时可能听的比较多的版本是，行盒高度是由这一行中最大的 line-height 决定的，这句话其实是错的，因为它完全忽略了 vertical-align 存在的情况。 IFC 一问中已经讲到，行盒由一行内联级盒组成，行盒的高度就是最高的盒（上半边距）顶部到最低的盒（下半边距）底部的距离。 line-height各属性值来回顾一下 line-height 可设置的属性值类型： Value: normal | &lt; number &gt; | &lt; length &gt; | &lt; percentage &gt; | inherit Tips：不可以对 line-height 设置负值！ normal 没什么太多可讲的，这是 line-height 的默认值。它实际表现等同于 1.1 ~ 1.2 number 指不带单位的数值。它的计算值是 line-height 乘当前元素的 font-size 假设我现在指定 font-size: 20px; line-height: 1.2; ， line-height 最后实际值为 20px * 1.2 = 24px length 就是直接指定带单位的值，如 px , em percentage 就是指百分比。它的计算值是百分比乘当前元素的 font-size inherit 因为浏览器实现方式差异较大，故不推荐使用 然后我就在想， line-height: 1.2 和 line-height: 120% 最后计算值都是一样，那为什么要设置两种方式呢？存在必有原因。 最重要的一点：line-height: 1.2 继承给子元素的是 line-height: 1.2 ，而 line-height: 120% 是先将 line-height 计算出来，再将此计算值继承给子元素。 line-height 为 0line-height 为 0 ，公式 上半行距 + 内容区域 + 下半行距 = line-height 依然成立，设内容区域高度为 h ，此时上下半距都为 -h/2 。但是文本在页面中是不会占据任何空间的。 图片底边距这里说个题外话。。。 line-height 对 img 是不起作用的，但是对同样是可替换元素的 input 却能起到作用，这是为什么呢？后来我想了想，是有原因的，因为 line-height 只能对文本起作用， input 里面是有可以文本的，而 img 中却不可以，同样 object 也是一样。 good luck 瞪大双眼看一看，图片底边与 div 底边并没有完全贴合，还有一个很小的间隙，这个其实是 line-height 与 vertical-align 共同作用带来的影响。 原因探析img 默认是 baseline 对齐，看一下图示。 红色的线是基线，绿色的线是底线，底线距离 div 底边还有很小的一点距离，就是下半边距。 我们的文字产生的匿名内联盒自然也是有高度的，基线以下的部分也得显示出来，所以图片下方边距，正是 文本基线到底线的距离 + 下半边距 。div 的高度就是它所产生的包含块的高度，就是行盒的高度总和（此例中只有一行，所以等于该行盒高），就是 图片高度 + 文本基线到底线的距离 + 下半边距 。 html5 带来的变化在 html4 中，如果没有文字则自然没有上面所说的图片底边距问题，但是情况在 html5 有了变化。 即使没有文本，图片也会当做它身边有文本存在，此时它会带来两种与 html4 不一样的表现。 永远存在图片底边距问题 如果图片高度低于文本高度， div 高度依旧等于文本高度 解决方法 div 设置 line-height: 0 或者 font-size: 0文本不占据空间，自然不会凸出来了。但是这个方法显然没有那么美妙，万一我有文字需要添加呢，是吧 img 设置 vertical-align: bottom让图片与行盒底部对齐，这样子文字就不会有一部分凸出来了。 img 设置 display: block 或者 float: left变成了块盒自然就没有基线对齐这些事了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之overflow]]></title>
      <url>%2F2016%2F09%2F15%2Frelearn_overflow%2F</url>
      <content type="text"><![CDATA[overflow 的知识点没有那么多，所以这篇文章里面概念性的东西只放了一个，干货实例反而很多，而且都是很多我们平时都必须要用的，也有一些可能容易被忽略的知识点本文都有提及。所以，不要没有耐心，这里都是你的菜！ 当然文章也从来不是科普文，了解 overflow 基本概念就点击 CSS overflow 。 常识拓展浏览器滚动条的来历我们都看过浏览器的滚动条，那浏览器的滚动条是从哪儿来的？答案是 html 而非是 body ，这里就不再去给例子论证了。 那IE7和之前的浏览器右边会一直存在一条滚动条，即使没有滚动。IE8开始，还有其他的浏览器却不是，那造成这一切的源头是什么呢？我们来看一下浏览器默认样式。 IE7浏览器默认： html { overflow-y: scroll; } IE8+浏览器默认： html { overflow: auto; } overflow-x/overflow-y只设置一个如果 overflow-x 和 overflow-y 值不同，且其中一个值显式设置为 visible 或未设置而默认为 visible ，而另外一个值是非 visible 的值，则 visible 值会被重置为 auto 。 按常理来说，我只给 overflow-x 设置了 auto ，那应该只生成横向滚动条。但恰恰是因为上面指出的特性， .wrap 元素的 overflow-y 也由 visible 变为了 auto 。 padding-bottom的缺失现象Chrome 支持，其他浏览器不支持 padding-bottom 。 在不同浏览器打开我的博客查看即可。 所以以后想添加这种效果或者计算滚动高度的时候要注意各个浏览器的兼容性。 JS计算页面滚动高度 Chrome 浏览器： document.body.scrollTop 其他浏览器： document.documentElement.scrollTop 所以如果想要获取页面滚动高度，推荐这样写： var st = document.body.scrollTop || document.documentElement.scrollTop 水平居中跳动问题我们是不是遇到过这么一种问题，本来页面高度不超过屏高，页面是没有滚动的，但是有一个展开的功能，把页面撑开了，滚动条就出来了。假设页面最外面的包裹元素是 .container 元素，它定宽且水平居中。在滚动条出现的这一刹那，它一定会被挤，向左偏移。因为是一下子偏移过去的，会有页面跳动的感觉。 解决方法有两个： html { overflow-y: scroll; } 这样子又回到了IE7年代了，很不推荐 .container { padding-left: calc(100vw - 100%); } 这样子就不会出现偏移跳动了，但是此时就算不上居中了。 自定义滚动条样式这里给出的是 webkit 内核的浏览器定义方式，IE的太丑就不介绍了。 123456::-webkit-scrollbar /*整体部分*/::-webkit-scrollbar-button /*两端按钮*/::-webkit-scrollbar-track /*外层轨道*/::-webkit-scrollbar-track-piece /*内层轨道*/::-webkit-scrollbar-thumb /*滚动滑块*/::-webkit-scrollbar-corner /*边角*/ 实际开发常用的就下面几个： 123456789101112::-webkit-scrollbar &#123; /*滚动条宽高*/ width: 8px; height: 8px;&#125;::-webkit-scrollbar-thumb &#123; /*滚动滑块*/ background-color: rgba(0,0,0,.3); border-radius: 6px;&#125;::-webkit-scrollbar-track &#123; /*轨道背景*/ background-color: #ddd; border-radius: 6px;&#125; absolute 溢出 我勒个擦，不是已经设置了 overflow: hidden 了吗，怎么还能出去？绝对定位要上天了。。。 先找一下相关的官方解释： 绝对定位元素不总是被父级 overflow 属性裁剪，尤其当 overflow 在绝对定位元素及其包含块之间的时候。 【包含块】：此处的包含块指 position 不为 static 的元素 哦，原来是这样， overflow 确实在绝对定位元素及其包含块（根元素）之间，所以压根管不住他。 有问题就得解决问题啊！下面提供两种方法来解决这种问题。 解决方法 overflow 元素自身为包含块 overflow 元素和绝对定位元素 中间的元素为包含块 设置非 static 的 position 即可。 实际案例下面是前两天leader要我们解决的一个案例的简化版。真实案例中，滚动窗中是一个表格，每一行中都有一个待提示字段，但是leader希望能够让出现的提示文本悬浮在滚动窗之上。 反正我到现在没找到实现的可能性，因为如果去除 relative ， 绝对定位元素将会跑到滚动窗外边去，不去除 relative ，就一定会被限制在里面。昂，就是无解喽！ 配合 overflow 才能实现的效果resize 拉伸 必须配合非 visible 的 resize 才能实现。 文字溢出以 ‘…’ 显示 之前讲解 BFC 的时候，详细分析了它的各项特性， overflow 恰恰能够触发它，所以如果记不太清就赶紧回去翻翻看昂。 今天还找到了一种比较好的写博客的方法，一边学习的时候一边在新建文件中写下来，写博客的时候一是方便整理思路，而是省去了一些重复劳动力，速度上去了好多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之z-index]]></title>
      <url>%2F2016%2F09%2F13%2Frelearn_z-index%2F</url>
      <content type="text"><![CDATA[What’s z-indexz-index 会为当前的盒创建层叠上下文，也会指定该盒在父级层叠上下文中的层叠等级。 What the fuck！ 怎么越说越乱！什么是层叠上下文？什么是层叠等级？ 一个页面我们平时看到的是平面的，我们感觉它就是一个水平面（二维）的东西。但是为什么元素互相之间覆盖，这就说明，它们在垂直方向上是有顺序的。一个盒创建了层叠上下文，就是给它自己划了一片自治区，下面的盒无论是排资论辈，抑或是创建了层叠上下文，都只能在这片区里面待着。 定位（position 不为 static）的盒和flex盒的子元素都会有一个层叠等级，这个层叠等级就是 z-index 值，默认值 auto 我们可以理解为 0 。这就是为什么其他的没有层叠等级，因为 z-index 对它们无作用。层叠等级就是用来排资论辈的，等级高的在上面，等级低的在下面。但是，同一父级层叠上下文的层叠等级才有意义。 层叠等级只需要理解就好，真正的重点是层叠顺序。 层叠顺序 页面中所有元素都脱离不开这张七阶图，有了它我们可以知道所有元素在z轴上的先后顺序。图中越是靠前的元素，它离我们的眼睛越近，覆盖其他元素的能力就越强。七阶层叠图示中的层叠顺序指的是同一层叠上下文中的元素的层叠顺序。 当然，这里还有两点需要补充一下： z-index越大，越靠前，这就是用层叠等级来排资论辈的。 层叠顺序、层叠等级（如果有的话）相同的两个元素，后面的会覆盖前面的。 上面以及后面要讲的 “靠前” 就是z轴上越高，层叠顺序也越高。 极易混淆易错点子层叠上下文无法比父层叠上下文低我们有时候会希望让子元素居于父元素下方，我们可能会立即想到给子元素设置一个比父元素更低的z-index，结果肯定得不到我们希望的效果。 回顾一下层叠七阶图，会发现，父层叠上下文的 background 处于第一阶，而子层叠上下文 z-index 为负，处在第二阶，子层叠上下文的层叠顺序在父层叠上下文之上！！！它们是父子层叠关系，不是兄弟层叠上下文，所以不能通过 z-index 来比较它们的层叠等级。 那如何才能让子元素在父元素之下呢？让父元素不产生层叠上下文，并且让子元素 z-index 为负就可以了。 层叠上下文不关心父子元素关系，它只关心父子层叠上下文。 不同上下文中的元素的比较不取决于自身上面那句话可能看着拗口不好理解，那我们看一下下面的例子辅助理解一下。 我们可以看到 .inner1 元素的 z-index 设置到了 9999 ， .inner2 元素的 z-index 设置到了 0 ，但是后者就是覆盖了前者，为什么呢？为什么呢？ 我们前面说了，元素层叠顺序只能够在自身所处的层叠上下文中比较，那和其他上下文中的元素怎么比较呢？拼爹!!! 这确实是一个很有意思的词，我来解释一下，就是说，处于同一层叠上下文的 A,B 两个元素，它们都创建了各自的层叠上下文，如果 A 层叠等级高于 B ，那么 A 下面的所有元素在z轴上高于 B 下面的所有元素。 z-index:auto;与z-index:0;的异同我们下面会介绍哪些元素会创建层叠上下文，但是不代表能够创建层叠上下文的元素就可以显式地设置 z-index 。这些元素中不能设置 z-index 的，他们最后的表现其实就是 z-index:auto; 。 那 z-index:auto; 和 z-index:0; 的相同之处在于，计算层叠等级的时候指定为 auto 的 index 实际计算值就是 0 。不同之处在于， z-index:auto; 不能创建层叠上下文，但是 z-index:0; 却可以。 position:relative; 元素默认 z-index:auto; ，根据我们之前论证出来的，子层叠上下文无法比父层叠上下文低。上面的例子表明， z-index:auto; 并不能创建层叠上下文。但是有个例外， position:fixed; 元素可以创建。 哪些元素可以创建层叠上下文我们在这里呢，把它们分成两部分，第一部分是 CSS2.1 中定义的可以创建的，第二部分是 CSS3 中新增的。 CSS2.1 中规定的 根元素 HTML z-index 不为 auto 的定位元素——实际情况有出入，z-index:auto;与z-index:0;的异同 一节已经讲了 CSS3中新增的 z-index 值不为 auto 的 flex 项(父元素 display:flex|inline-flex) 元素的 opacity 值不是 1 元素的 transform 值不是 none 元素 mix-blend-mode 值不是 normal 元素的 filter 值不是 none 元素的 isolation 值是 isolate will-change 指定的属性值为上面任意一个 元素的 -webkit-overflow-scrolling 设为 touch 这里除了 flex 项，其他的都不能设置 z-index ，实际表现就是 z-index:0;。 z-index 平时真是被我们滥用了，有时候为了做一个弹出层效果，就随便设置一个 z-index:9999; ，这是一个坏习惯，所以我们要尽可能的利用层叠顺序规则来更规范地实现效果。 小小的一个属性牵扯了这么多内容，深入理解CSS，下节更精彩。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之BFC & IFC]]></title>
      <url>%2F2016%2F09%2F06%2Frelearn_bfc_ifc%2F</url>
      <content type="text"><![CDATA[BFC、IFC的概念重要吗？不重要，没有它们我们也能写出符合要求甚至很好的页面。重要，深入了了解了CSS这门语言的核心，你的CSS才可能会有创造性，你才能发明出你自己的奇淫技巧，而不是遇到新的情境就去百度，google。 在看这篇文章之前，先得了解一些无聊的基本概念，重拾CSS规范之从盒类型谈起，当然，我已经尽可能让它有趣了。 FCFC（Formating Context，格式化上下文） 是一个布局的环境，它里面的盒子需要遵循FC这套体系的规则， CSS2.1 中定义了 BFC（Block Formating Context，块级格式化上下文） 和 IFC（Inline Formating Context，内联格式化上下文）， BFC 讲的是块级盒子的布局规则， IFC 讲的是内联级盒子的布局规则。 BFC脱离特性讲定义都是流氓！！！光看个定义不好使，赶紧来捋一捋 BFC 的家规吧。 1. 浮动，绝对定位元素，非块盒的块容器（例如，inline-blocks，table-cells和table-captions）和’overflow’不为’visible’的块盒会为它们的内容建立一个新的块格式化上下文。 这里只说明了一点： 如何触发BFC！（很重要啊，多练多记忆，一定要熟稔于心） 2. 在一个块格式化上下文中，从包含块的顶部开始，盒在竖直方向一个接一个地放置。两个兄弟盒之间的竖直距离由’margin’属性决定。同一个块格式化上下文中的相邻块级盒之间的竖直margin会合并。 关于 margin 合并的问题，我在这篇文章里面已经描述的很详细了：重拾CSS规范之margin 透过下面的DEMO来看看如何阻止 margin 合并： margin 一文中 margin合并规则 中写到了这么一句话，新建了块格式化上下文的元素不会与它的子元素的 margin 合并，所以 .wrap 元素就不会合并 .first 元素的 bottom margin 了，也就无法与 .second 元素发生 margin 合并了。 而且我们可以发现， BFC 就是一个密闭的容器 ， BFC 里面的元素无法对外界元素在布局上产生直接的影响。（为什么我要用‘直接’呢，因为它完全可以撑开 BFC 元素，来‘挪动’外界元素的位置） 那我们再考虑一个问题， 产生了新的 BFC 的盒会与它的兄弟盒产生 margin合并 吗？ 当然是会的。 3. 在一个块格式化上下文中，每个盒的left外边挨着包含块的left边（对于从右向左的格式化，right边挨着）。即使存在浮动（尽管一个盒的行盒可能会因为浮动收缩），这也成立。除非该盒建立了一个新的块格式化上下文（这种情况下，该盒自身可能会因为浮动变窄） 这里主要涉及到的就是多栏自适应布局的应用了。 如果要控制两者之间的间距，最好对 .left 元素使用 margin-right 。因为如果对 .center 元素使用 margin-left 的话，首先 margin-left 值必须要超过 .left 元素的宽度值，否则无法体现作用；再者对 .center 元素设置 margin-left 了，不就又回到了流体自适应布局了吗！ 4. 在计算生成了 BFC 的元素的高度时，其浮动子元素应该参与计算。 几年前我技术很差的时候总在疑惑，float元素没法撑开父元素高度，但是为什么给父元素增加设置不为 ‘none’ 的 ‘float’ 值就可以了，现在总算是解开谜题了。。。 IFC上一篇文章中已经提到了很多 IFC 相关的知识，这次再补充一点。 IFC 中的盒子与 BFC 中的不同的是，它们可以水平依次放置。 IFC中的行盒的宽度是包含块的宽度减去 float 元素（如果有的话）的宽度，行盒高度是最高的盒的top与最低的盒的bottom之间的距离。 内联盒的高度是由line-height决定的，而可替换元素，inline-block，inline-table 元素的高度则是由它们的 margin 盒高度决定的。 关于行高的计算后面会有较大篇幅的文章来介绍，敬请期待！ ‘display’，’position’与’float’之间的关系如果’position’值为’absolute’或者’fixed’，或者’float’值不为’none’，或者该元素是根元素，那么display就根据下表来设置。 同时设置’absolute’或者’fixed’、非 ‘none’ 的 float，float 会被覆盖为 ‘none’。 指定值 计算值 inline-table table inline, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, table-caption, inline-block block 其它 与指定值相同]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之从盒类型谈起]]></title>
      <url>%2F2016%2F09%2F02%2Frelearn_box_type%2F</url>
      <content type="text"><![CDATA[今天要写的不是CSS标准盒模型和IE盒模型，那个烂大街了。今天要深入探讨的是CSS去控制页面布局背后的那一套规则，页面就是由很多个各式各样的盒组成的，那我们就聊这个。这个是对后面的BFC以及定位模式的一个铺垫，基础很重要！！！ 术语普及 盒： 每个元素都会生成一个盒，用来容纳后代（生成的盒）和自己生成的内容(比如说一段文字)。所以我们可以把一个页面看做是由一个个的盒子堆砌而成的，只是这些盒子也分种类，就像这个社会在视觉上由男人和女人构成。块级元素： display 为 block/table/list-item 的元素。块级盒： 块级元素生成的盒块容器盒： 块级盒同时也是块容器盒，除了表格盒与可替换元素。顾名思义，块容器盒就是它要容纳后代和它自身的内容。这里面我发现了一个很有趣的事儿，可替换元素，所以它们都是通过 value/src 之类的属性来控制内容显示，可能正是因为它们 无法添加后代元素（或者必须添加特定子元素） 的特性所以才不算是块容器盒的。内联级元素： display 为 inline/inline-block/inline-table 的元素。内联级盒： 内联级元素生成的盒。但是只有 inline 元素生成的盒才叫做内联盒，它区别于 inline-block 元素的内联级块盒。行盒： 内联格式化上下文中，包含来自同一行的盒的矩形区域叫做行盒可替换元素： 浏览器根据元素的标签和它的属性来决定元素的具体显示内容。比如 &lt;img&gt; &lt;input&gt; &lt;textarea&gt; &lt;select&gt; &lt;object&gt;。 内联元素的一个小特性这里单独把内联元素给拿出来了，内联元素必须要区别于内联级元素，内联元素只是指 diaplay 为 inline 的元素。 margin-top,margin-bottom 对内联元素无效。padding-top,padding-bottom 对内联元素有效，但它们不能对布局产生任何影响。 上面第一句话比较容易理解，第二句话可能需要通过例子辅助理解。 上图中 padding-top 和 padding-bottom 会影响到块级元素 content 区域位置，会让块级元素的空间真正意义上的变大，进而影响其他元素的位置。但是再看内联元素这边，我们可以看出来 padding 确实存在，但是它没有起到任何影响，没有能够让内联元素占据的空间变大，布局上没有对元素自身起到任何影响，更别提对其他元素产生影响了。可能唯一的作用就是设置 background 的时候， padding 能起到作用。 匿名盒CSS为了方便布局，它规定：一个块容器盒要么只包含块级盒，要么只包含内联级盒。 匿名块盒我们来看看CSS会如何对待这段代码： 12345&lt;div&gt; &lt;span&gt;我是span内的文字&lt;/span&gt; &lt;p&gt;我是p内的文字&lt;/p&gt; 我是没有任何标签包含的文字&lt;/div&gt; 大家好，我是 div ，我是一个块容器盒，我发现我的儿子 p 生成了块级盒，那么我其他的儿子也必须都是块级盒。sorry， span 龟儿子，麻烦你变个身，变成块级盒。卧槽，’我是没有任何标签包含的文字’ 这段文本不太好处理啊，他又不是我儿子，不好直接命令他。 幸好老子灵机一动，要不我干脆认他做个干儿子。 div：“文本小孩儿，你愿意做我的干儿子吗？” 文本：“我愿意，爸爸！” div：“真是个好孩子。但是呢，今天这情况，你们都必须要有一个块级盒，你其他的哥哥们自己会生产，看你小子啥也不会，爸爸就送你一个吧，不过这个盒子无名无分，我们就叫它匿名块盒” 准备工作都做好了，再来看看他们家的家谱吧！ 我们可以看到，上面 span 也变成块级盒了，那我们是不是像对待块级元素一样给它设置宽高呢？当然不能！！！所以说，上面的图片是错误的！！！ 其实呢， span 这小子作弊了，它明明只是猴子派来的逗逼，当然不能像猴子一样变身，那层块级盒（block box）是它老爸发放的作战物资——匿名块盒。所以呢，真实的情况是：它自己本身只能产生内联盒，然后在它外面还会包裹着一个匿名块盒。 那我们来看一看正确的家谱： 正是因为匿名盒的存在， span 和那段小文本也能够像块级元素一样，单独占据一整行。 那再有一个问题，几个内联元素在一起，它们明明是同一行排列啊，并没有像块级元素一样换行显示。其实呢，多个内联元素在一起，匿名块盒会把相邻的内联盒“打包”，一起包裹起来。 匿名内联盒任何被直接包含在一个块容器元素中（不在一个内联元素里面）的文本，必须视为一个匿名内联元素。 再来看一段代码： 1234&lt;p&gt; &lt;span&gt;我是span中的文字我是span中的文字我是span中的文字&lt;/span&gt; 我是没有任何标签包含的文字&lt;p&gt; 大家好，我是 p 元素，我今天看了看我的儿子们，不容易啊，一个块级盒也木有昂，按照CSS当年定下的规矩，这样的情况下，本王必须建立内联格式化上下文（IFC）来安置这群傻孩子。 span 好说啊，自己本身就生成了内联级盒，麻烦的就是这个没有任何标签包围的文本了。咱们还用老方法行不行(⊙v⊙) p：“文本小孩儿，你愿意做我的干儿子吗？” 文本：“我愿意，爸爸！” p：“真是个好孩子。但是呢，今天这情况，你们都必须要有一个内联级盒，你其他的哥哥们自己会生产，看你小子啥也不会，爸爸就送你一个吧，不过这个盒子无名无分，我们就叫它匿名内联盒” 闲话不多说，看家谱： 我们可以看到如果一个行盒无法容纳下某个内联盒，这个内联盒就会分割开来放在多个行盒中。注意一下在换行（分割）的地方，是没有竖直线的，表示内联盒未结束，而且 margin,padding 值在这里是不会体现出来的， margin-left,margin-right,padding-left,padding-right 值只存在于内联盒的开始和结束的地方。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之margin]]></title>
      <url>%2F2016%2F07%2F30%2Frelearn_margin%2F</url>
      <content type="text"><![CDATA[好久没写博客了，甚是惭愧啊，md语法都快忘了。最近一直在忙着巩固基础，实在是厌倦那种似懂非懂的感觉。有的时候bug出来了，拿别人的代码可能一下子就解决了，可是知识面太零碎化。这篇文章不会涉及margin基本属性，因为这些网上都有。本文内容量不会特别大，但是里面的知识点很多人在实际开发中却会混淆。 margin有效性 margin对 display:table; 系列（这其中不包含 table-caption， table 和 inline-table） 以外的所有元素有效 margin-top 和 margin-bottom 对不可替换的内联元素无效 margin百分比值百分比根据生成盒的包含块的width来计算。 我们来看看关于包含块的几种情况： 如果该元素的position是 relative 或者 static，包含块由其最近的块容器祖先盒的content边形成 如果元素具有 position: fixed，包含块由连续媒体的视口或者分页媒体的页区建立 如果元素具有 position: absolute，包含块由最近的 position为 absolute，relative或者 fixed 的祖先建立，按照如下方式： 如果该祖先是一个内联元素，包含块就是环绕着为该元素生成的第一个和最后一个内联盒的 padding box 的边界框。 否则，包含块由该祖先的 padding 边形成 margin auto探讨我们是否有想过一个有固定宽度的div元素设置了 margin: auto; 为什么可以水平居中显示？为什么有固定高度却无法垂直居中显示？ why can 水平居中常规流中的块级不可替换元素的规则中包含这样两个规则： ‘margin-left’ + ‘border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ + ‘border-right-width’ + ‘margin-right’ = 包含块的宽度 如果’margin-left’和’margin-right’都是’auto’，那么它们的应用值相等。 举个栗子，假设 div 设置了固定宽度, padding 和 border 为零，当我们设置 margin: auto; 时，浏览器会设置 margin-left 等于 margin-right，并且解方程组求出正确的margin-left 和 margin-right 值。 只要常规流中的div有固定宽度，并且 padding 和 border 左右两边的数值大小一样，设置了 margin: 0 auto; 就能让其水平居中显示。 why can’t 垂直居中CSS2.1规范文档10.6.3节指出： ‘overflow’ 计算值为 ‘visible’ 时常规流中的块级不可替换元素 如果’margin-top’或者’margin-bottom’为’auto’，其应用值为 0。 所以说，管你有没有设定高度，你都会把你的 margin 上下值设置为 0。也就是垂直方向上 div 原地不动！ What else can 水平/垂直居中 by ‘margin: auto’除了本节的第一种情况外，还有一种情况，那就是 绝对定位元素 。 它不仅能够水平居中，同样能够垂直居中。 上面 top/bottom/left/right 我都设置的 0 ，当然也可以设置成非零元素，只需要让数值两两对称就行了，但是这样不够安全。举个栗子，有人作死，top/bottom 的值放得太大了，top + bottom + height + border + padding 超过了 包含块的高度，那咋办呢？？？ margin 不就要变成负值了吗？？？ 不会的，这时候，浏览器会忽略 bottom 值， margin-top/margin-bottom 置 0，根据方程式重新计算合适的 bottom 值，而我们里面的 div 就不会垂直居中了，它会根据 top 来定位。 所以么，能不作死就不要作死了，上面的代码示例又方便又安全。 margin合并margin合并也可以叫做外边距叠加，这是一个简单的概念，指的就是两个或者多个盒的相邻的margin可能会合并在一起。如果还不能理解的话，我们用图示来理解一下。 当一个元素出现在另一个元素上面时，第一个元素的底外边距与第二个元素的顶外边距发生叠加。 当一个元素包含在另一个元素中时，它们的顶外边距或者底外边距也会发生叠加。 甚至外边距还能与自身进行叠加。如果一个空元素，上下方向有外边距，但没有边框和内边距，这时候，上下外边距就会相遇，自然而然的叠加了。 如果这个外边距又遇到了其他元素的外边距（margin相邻），它们还能继续叠加。 O__O “…看来margin的世界里也会有小三小四的存在。 那我们有没有想过 CSS 工作组为什么会设立这么一个 bug 般的存在！这是为了服务段落元素 p 啊。 我们常见的段落与其他元素都会有间距，这是因为，用户代理给他们设置了默认margin值。可那为什么两个段落相遇，间距却没有拉大呢？这就是用到了我们上面所说的前后两个div，它们的底外边距和顶外边距叠加在一起了，共享一个外边距，自然就不会拉大了。 不是所有相邻的margin相邻都可以合并！！！ margin合并规则 水平方向的 margin 不会合并 一个浮动的盒与任何其它盒之间的 margin 不会合并（甚至一个浮动盒与它的流内子级之间也不会） 建立了新的块格式化上下文的元素（例如，浮动盒与 ‘overflow’ 不为 ‘visible’ 的元素）的 margin 不会与它们的流内子级合并 绝对定位的盒的 margin 不会合并（甚至与它们的流内子级也不会） 内联盒的 margin 不会合并（甚至与它们的流内子级也不会） 一个流内块级元素的 bottom margin 总会与它的下一个流内块级兄弟的 top margin 合并，除非兄弟有空隙 一个流内块级元素的 top margin 会与它的第一个流内块级子级的 top margin 合并，如果该元素没有 top border ，没有 top padding 并且该子级没有空隙 一个 ‘height’ 为 ‘auto’ 并且 ‘min-height’ 为 0 的流内块级盒的 bottom margin 会与它的最后一个流内块级子级的 bottom margin 合并，如果该盒没有 bottom padding 并且没有 bottom border 盒自身的 margin 也会合并，如果 ‘min-height’ 属性为 0 ，并且既没有 top 或者 bottom border ,也没有 top 或者 bottom padding ，并且其 ‘height’ 为 0 或者 ‘auto’ 当两个或者更多的 margin 合并时，产生的 margin 宽度为合并 margin 宽度中的最大值。至于负 margin ，就从正相邻 margin 的最大值中减去负相邻 margin 的绝对值的最大值。如果没有正 margin ，就用 0 减去相邻 margin 的绝对值的最大值。 margin常见bugIE6双边距bug场景： 当给父元素内第一个浮动元素设置 margin-left 或 margin-right 时 margin 加倍。解决办法：给第一个浮动元素设置属性 display:inline; IE6中3px偏移bug场景： 当一个非浮动元素与一个浮动元素相邻时，他们之间会多出 3px 的间隔。如果非浮动元素没有设置高度，将使非浮动元素中的内容与其多出 3px 间隔，如果设置了高度，则是 div 之间多出了 3px 间隔。解决方法： 设置非浮动元素 float:left; 一起浮动；或者为右边元素添加 IE6 Hack——为非浮动元素设置高度 _min-height:1%;。这时文本3px偏移会消失，但时候出现元素盒偏移，只需要再为浮动元素设置 _margin-right:-3px;就可以了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之this]]></title>
      <url>%2F2016%2F06%2F14%2Fdeeply_understand_this%2F</url>
      <content type="text"><![CDATA[这篇文章其实几天前就想写了，但是近日又看到了 this 的很多用法，诸如硬绑定、软绑定，都没用到过。所以不禁感慨，学无止境啊。 this 根据情境不同，指向性差异很大，所以今天就是进行一个简单的梳理，并且对其进行一些原理性的分析。 前言关于this的误解有很多，有人认为 this 指向函数自身，有人认为 this 指向函数上一级，诸如此类的太多了,甚至就连《高程》中对其都有一个不太严谨的描述： 在全局函数中， this 等于 window ，而当函数被作为某个对象的方法调用时，this 等于那个对象。 今天我们就来探讨一下this的正确打开方式。 What’s this前一篇文章中提到过， this 是执行上下文的一个属性，它不是一个变量，所以我们不能对其进行赋值操作，否则会报错；同时 this 属性是在函数调用时才确立的，它与函数如何定义没有任何关系，它只能决定于它的调用方式。 那今天的重点就是讨论几种调用方式了？当然不是，重点就是了解一下 this 是如何来寻找指向对象的，这里就要引出我们的 引用类型 了。 引用类型引用类型有两种情况：标识符和属性访问器。在处理引用类型的时候，会返回一个引用类型值，我们用伪代码来表示一下： 12345678var reference = &#123; // 拥有这个属性的对象 base: &lt;base Object&gt;, // 引用名 referenceName: &lt;reference name&gt;, // 严格模式标记（boolean） 后面省略这个属性（不太用得到） strictReference: &lt;strict flag&gt;&#125; 举个栗子： 1234var obj = &#123; bar: function () &#123;&#125;&#125;;function foo() &#123;&#125; 在调用的中间结果中，返回了如下的引用类型的值： 12345678var barReference = &#123; base: obj referenceName: bar&#125;;var fooReference = &#123; base: global, referenceName: foo&#125;; 到了这里，准备工作已经做好了，下面就是 this关联规则 粉墨登场了。 在一个函数上下文中，先判断调用括号 () 的左边是否为引用类型， 如果不是则将 this 设置为 undefined ， 如果是，再判断引用类型是否为属性引用，如果不是则将 this 设置为 undefined ，如果是，则将 this 设为引用类型值的 base 对象。如果 this 的值为 undefined ，其值会被隐式转换为全局对象；而如果在严格模式下，undefined 不可以被隐式的转换 。 下面我们就要通过具体的几个情景来看一下关联规则是如何具体运作的。 独立函数调用独立函数的调用我这里将它分为独立全局函数调用和独立内部函数调用，什么叫做独立呢，就是直接调用，不显式依托对象。 独立全局函数调用先看看一个简单的例子： 1234function foo() &#123; console.log(this);&#125;foo(); // window (global对象无法直接访问) 让我们来分析一下上面的代码产生了什么引用类型值： 1234var fooReference = &#123; base: global, referenceName: foo&#125;; 如果在非严格模式下， this 会指向全局对象（ global 对象无法直接访问，但是 global 的 window 属性引用了 global ，所以上面会输出 window ）。但是在严格模式下， this 值将被设为 undefined 。 123456function foo() &#123; "use strict"; console.log(this);&#125;foo(); // undefined 严格模式与函数调用位置无关，只与函数定义有关。当然，如果你是全局使用严格模式，就不必考虑它了。 123456789function foo() &#123; console.log(this);&#125;(function()&#123; "use strict"; foo(); // window&#125;); 独立内部函数调用内部函数就和全局函数虽然名字很近似，但他们却有本质上的区别。哈哈，这里就不卖关子了，先来看代码： 123456789function foo() &#123; function bar() &#123; console.log(this); &#125; bar();&#125;foo(); // window 这里呢， foo() 内 bar() 最终输出 window ，这是为什么呢！！！ 是这样的，我们来看一下上面代码产生的引用类型的值： 1234var barReference = &#123; base: AO(fooReference), referenceName: bar&#125;; 这里的 base 被绑定了 foo 函数活动对象，可是函数调用并不是属性调用，所以根据上面的规则， this 被赋值为 undefined ，并隐式地转换为全局对象。 关于引用类型的base对象以及属性名是怎么寻找的，以及什么时候寻找的，将在作用域那一篇文章中进行介绍。 方法调用我们拿个栗子边吃边聊： 1234567var obj = &#123; foo: function() &#123; console.log(this); &#125;&#125;;obj.foo(); // obj 它产生的引用类型的值： 1234var fooReference = &#123; base: obj, referenceName: foo&#125;; 就近原则对象属性引用链中只有最后一层（最靠近调用函数）会影响调用位置。举例来说： 123456789101112function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo: foo &#125;;var obj1 = &#123; a: 2, obj2: obj2 &#125;;obj1.obj2.foo(); // 42 绑定丢失有一种情况我们需要考虑一下，就是进行传值的时候； 12345678var obj = &#123; foo: function() &#123; console.log(this); &#125;&#125;var bar = obj.foo;bar(); // window 我们可以看到 bar() 输出的值变了，因为在进行调用的时候, bar 生成了一个新的引用类型值： 1234var barReference = &#123; base: global, referenceName: bar&#125;; 难道这就没了吗？当然不！我们引出这个概念，必须得有注意事项啊！ 当我们把对象属性函数引用传递给函数或者是内置函数当做参数时，回想一下我们之前提到过的，它们会发生一个隐式的赋值传递，所以，这个时候就会发生绑定丢失。 123456789101112function bar(m) &#123; // 这里发生了一个隐式的赋值，m = obj.foo; m();&#125;var obj = &#123; foo: function() &#123; console.log(this); &#125;&#125;bar(obj.foo); // window call、apply调用 .call() 、 .apply() 调用比较类似，它们的第一个参数都是传递给 this 的值，不同的是， .call() 后面的参数可以是任意值， .apply()第二个参数为传入值组成的数组（只有两个参数）。 老板，再来一个栗子： 12345678function foo() &#123; console.log(this.a);&#125;var obj = &#123; a:2&#125;;foo.call(obj); // 2 通过 foo.call(...) ，我们可以在调用 foo() 时将 this 强制绑定到 obj 上。 bind调用 .bind() 是ECMAScript5中在函数原型上添加的方法，它将参数传递给this，并返回新的硬编码（函数内部显式绑定this）函数。 12345678910function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 1&#125;var bar = foo.bind(obj);bar(); // 1 API调用第三方库以及许多javascript中内置函数，会提供一个可选参数，成为“上下文”，确保你的回调函数使用指定的 this 。 For example： 123456789function foo(el) &#123; console.log(el, this.id);&#125;var obj = &#123; id: "awesome"&#125;;// 调用foo(..)时把this绑定到obj[1, 2, 3].forEach(foo, obj);// 1 awesome 2 awesome 3 awesome 构造函数大家都在说作为构造器调用的函数中的 this 都被设置为了新创建的对象，轻飘飘的一句话，我也能记住，可是究其原理呢？ 我们来看一下ECMA5中对new过程的解释吧：（主要是ECMA6整的太复杂了） Let ref be the result of evaluating MemberExpression. Let constructor be GetValue(ref). Let argList be the result of evaluating Arguments, producing an internal list of argument values. If Type(constructor) is not Object, throw a TypeError exception. If constructor does not implement the [[Construct]] internal method, throw a TypeError exception. Return the result of calling the [[Construct]] internal method on constructor, providing the list argList as the argument values. 这是针对有参构造函数的，如果是无参构造函数，则省去第三步。其大概意思是 ‘ new ‘ 后面必须跟一个对象并且该对象必须有一个名为 ‘ [[Construct]] ‘ 的内部方法，否则抛出异常。如果以上条件都成立，就执行 ‘ [[Construct]] ‘ 方法。 我们再来看看 [[Construct]] 内部方法是如何实现的： Let obj be a newly created native ECMAScript object. // 新建原生 js 对象 obj Set all the internal methods of obj as specified in 8.12. // 把 obj 的内置方法都设置好，它们都在8.12中罗列出来了 Set the [[Class]] internal property of obj to “Object”. //把 obj 的 [[Class]] 内部属性设置为 ‘object’ Set the [[Extensible]] internal property of obj to true. // 设置 [[Extensible]] 为 true Let proto be the value of calling the [[Get]] internal property of F with argument “prototype”. // 调用 [[get]] 方法得到构造函数 F 的 prototype 的值,赋给 proto If Type(proto) is Object, set the [[Prototype]] internal property of obj to proto. // 如果 proto 是一个对象，将 obj 的 [[Prototype]] 设置为proto If Type(proto) is not Object, set the [[Prototype]] internal property of obj to the standard built-in Object prototype object as described in 15.2.4. // 如果 proto 不是对象，则将 [[Prototype]] 设置为标准内置 Object 对象的 prototype 对象。 Let result be the result of calling the [[Call]] internal property of F, providing obj as the this value and providing the argument list passed into [[Construct]] as args. // 调用构造函数 F 的内部 [[Call]] 方法并赋值给 result ，调用时提供 obj 作为 this 的值，将传入参数作为入口参数 If Type(result) is Object then return result. // 如果 result 是对象，则返回 result 。 Return obj. // result 不是对象则返回 obj 。 间接引用当我们进行一些诸如赋值、 || 、 &amp;&amp; 之类的操作时，会不经意地创建一个“函数引用”。 1234567var obj = &#123; foo: function () &#123; console.log(this); &#125;&#125;;(obj.foo = obj.foo)(); // window 这里输出window的原因就是因为 (obj.foo = obj.foo) 中存在 = ， 它使得赋值前它右边的 obj.foo 调用了 getValue 方法， getValue 方法返回了 function 的引用，所以这里就等于独立函数调用了。 箭头函数ECMAScript6中新添了一种箭头函数，它无法与上面四种情况混用，它的 this 取决于外层函数调用时绑定的 this ，而且它一旦被绑定无法更改。 12345678910111213141516function foo() &#123; return (a) =&gt; &#123; console.log(this); &#125;&#125;var obj1 = &#123; a: 1&#125;;var obj2 = &#123; a: 2&#125;;var bar = foo.bind(obj1);var baz = bar.call(obj2);baz(); // 1 不是 2，因为一旦绑定则无法更改 this 这一篇真的写了有一天了，有了很多感想，很多自己以为会了的东西其实根本就没有懂，因为写着写着就会发现自己有很多特别细节性的东西不值得推敲，甚至会有冲突，然后再逼着自己去找资料，看ECMA规范，这两天提高了很多吧。这是个好事也不是个好事，下次应当在写博文之前就整个地梳理遍，这样子知识才能更系统的消化，不至于显得写博客仅仅是来发现自己的不足。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之执行上下文]]></title>
      <url>%2F2016%2F06%2F09%2Fdeeply_understand_execution_contexts%2F</url>
      <content type="text"><![CDATA[当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。 如果你刚看《高程》，看到这句话估计会似是而非的理解。其实我当时也是，直到最近撸第二遍，也是偶然看到大叔的系列文章，有心研究了下，加上自己的理解，促成了这几篇博文。今天我们先来聊聊执行上下文与活动对象。 执行上下文执行上下文可能不太容易理解，其实它就是上面写到的执行环境，代码就是在相对应的执行环境中运行的。所以我们可以这样理解，每当调用一个函数，就会相应地为这个函数划出一块地，该函数所有的代码活动都被限制在这块地上。 好，这里我们可以引出两个问题：这块地是什么？只有函数调用才能创建EC吗？ 这块地是什么？当然就是内存了。无论是js还是其他代码，代码的运行所需空间都是由内存来分配的。内存分堆(heap)和栈(stack)，在这里，执行上下文组成了 执行上下文栈 来调控代码的进行，执行上下文栈的顶端就是正在使用的上下文。我们来用图示看一下： 123456789101112var a = 1, b = 2;function foo() &#123; a = 3; bar(); alert(a + b);&#125;function bar() &#123; b = 3;&#125;foo(); 当程序结束时，全局上下文出栈并销毁。 相信大家也注意到了上面出现了很多次的 全局上下文 ，它可以很好的回答我们的第二个问题：不是! 那么，问题就来了。。。 什么代码可以创建EC？ 全局代码 函数代码 Eval代码 全局代码全局代码就是 &lt;script&gt; 标签中的，或者是通过外部加载的js文件中的代码，它不包含任何函数体内的代码。全局代码创建的EC就是我们上文中所提的全局上下文，它是程序刚开始，代码尚未执行时就产生的上下文，它永远处在执行上下文栈的底部。 函数代码 function 函数中的代码段就是函数代码，它也不包括内部函数代码。 函数如果递归调用自身，每调用一次都会创建一个新的执行上下文。如果函数体内有 return ，执行到它的时候会立刻退出当前执行上下文。 Eval代码Eval代码和函数代码类似，执行到它的时候也会创建一个新的执行上下文。但不同的是，它有一个调用上下文（calling context），同样会压入ECStack。eval函数中如果进行变量、函数声明，将会体现到调用上下文中。 不过eval会使阅读性、安全性、性能下降，不建议大家使用。 变量对象代码执行的时候访问的变量都是从变量对象中取到的。 变量对象（Variable Object）其实是执行上下文的一个属性，执行上下文还有 this 和 作用域 属性。它们介绍起来篇幅很大，所以我把它放到了后面的文章。 变量对象分为两类：1.全局上下文变量对象2.函数上下文变量对象 全局上下文中的变量对象全局上下文变量对象就是全局对象。 全局对象本身包含很多属性如Math、String、Date、parseInt等等，大家不妨用 console.log(this) 在控制台中查看一下，还有，在全局作用域中声明的变量和函数也会成为它的属性。 当访问全局对象的属性时通常会忽略掉前缀，这是因为全局对象是不能通过名称直接访问的。不过我们依然可以通过全局上下文的this来访问全局对象，同样也可以递归引用自身。例如，DOM中的window。 函数上下文中的变量对象函数上下文中存在的是活动对象，它可以当做变量对象使用，其中包含变量、函数声明、形参、arguments。 我们来配合一个例子看一下： 12345678var a = 10; function foo(b) &#123; var c = 20; c += b;&#125;;foo(30) 对应的变量对象是： 123456789101112// 全局上下文的变量对象（不包含自带属性）VO(globalContext) = &#123; a: 10, foo: &lt;reference to function&gt;&#125;VO(foo functionContext) = &#123; // arguments其实是一个类数组对象，可以通过下标来访问实参，它同时包含callee、length、properties-indexes三个属性 arguments: &lt;ArgO&gt; b: 30, // 形参 c: 20 // 变量&#125; 我们想一个问题，变量对象是初始化时就是这样吗？其实不是这样，执行上下文中的代码分两个阶段，不同阶段值不同，这也是js的很重要的一个特性。 执行上下文的两个阶段我们透过这段代码在不同时期的变量对象看一下。 12345678function test(a, b) &#123; var c = 10; function d() &#123;&#125; var e = function _e() &#123;&#125;; (function x() &#123;&#125;);&#125; test(10); // call 进入执行上下文这个阶段处于代码执行之前，此时执行上下文的VO已经包含函数声明、形参、变量、arguments。其实这个阶段就是声明提升的阶段。 此时AO对象数据为： 类型 赋值与否 变量 undefined 函数声明 对函数的引用 形参 赋值 arguments 赋值 建议大家配合 Javascript深入浅出之声明与提升 中的 提升规则 一起看看。 对应变量对象： 12345678// 活动对象AO(test) = &#123; a: 10, b: undefined, c: undefined, d: &lt;reference to FunctionDeclaration "d"&gt; e: undefined&#125;; 代码执行此时AO对象数据为： 类型 赋值与否 变量 赋值 函数声明 对函数的引用 形参 赋值 arguments 赋值 在这个阶段中，AO被改成了 12AO['c'] = 10;AO['e'] = &lt;reference to FunctionExpression "_e"&gt;; 到了这里，相信大家都对函数调用阶段有个很多本质的理解，配合本文也可以更好地理解声明提升，也为后面理解闭包打好基础。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之声明与提升]]></title>
      <url>%2F2016%2F06%2F07%2Fdeeply_understand_statement_promotion%2F</url>
      <content type="text"><![CDATA[var 声明了一个变量，同时可以初始化该变量。 1var name1 [= value1 [, varname2 [, varname3 ... [, varnameN]]]]; 单 var 模式在函数的顶部使用一个单独的 var 语句是非常推荐的一种模式，它有如下一些好处： 在同一个位置可以查找到函数所需的所有变量 避免当在变量声明之前使用这个变量时产生的逻辑错误 提醒你不要忘记声明变量，顺便减少潜在的全局变量 代码量更少（输入更少且更易做代码优化） 单 var 模式看起来像这样： 123456789function func() &#123; var a = 1, b = 2, sum = a + b, myobject = &#123;&#125;, i, j; // function body...&#125; 单 var 衍生的误区123456function test() &#123; var param1 = param2 = 2;&#125;test();console.log(param1); // Uncaught ReferenceErrorconsole.log(param2); // 2 可能有人就会疑惑，为什么这里的 param1 是局部变量，而 param2 却是全局变量呢？ = 运算从右向左合并，上一段代码其实是这样运行的： 12345function test() &#123; var param1; param2 = 2; // 全局变量 （严格模式下会抛出错误） param1 = param2; // 局部变量&#125; 未声明变量 给一个非声明变量赋值会隐式创建一个全局变量（全局object的一个属性）。 这句话大家应该都很熟悉，即便你是刚入门的新手；但也有人不完全赞同这句话，他们感觉它不符合ECMAScript的基本变量的定义，它只算是全局属性；那我们就来细细探讨一下声明变量与未声明变量的区别： 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。 声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。 12345console.log(a); // Uncaught ReferenceErrorconsole.log(b); // 2 a = 1;var b = 2; 声明变量是它所在上下文环境的不可配置属性（non-configurable property），非声明变量是可配置的（例如非声明变量可以被删除）。 1234567var a =1;b = 1;console.log(delete a); // falseconsole.log(delete b); // trueconsole.log(this.a); // 1console.log(this.b); // Uncaught ReferenceError 所以，使用未经声明的变量会带来很多潜在的代码危险，也建议大家尽量不要使用；而且严格模式下会抛出错误。 提升先看一段代码： 123a = 2;var a;console.log(a); 很多人可能认为这段代码输出的是 undefined ；因为开始 a 被初始化为2，接着又被重新声明并被默认赋值为 undefined 。 再看下一段代码： 12console.log(a);var a = 2; 这段代码可能又会有人认为它要报错了，因为在执行 console.log 前 a 尚未声明。 其实刚才两段代码会分别输出 2 和 undefined ，那又是为什么呢？ 在引擎解释代码之前，编译器会预先对其进行编译，编译工作的其中一块就是将所有的声明预先进行处理。 当你看到 var a = 2 时，你以为直接就是将 2 赋值给 a ，其实它会分成两个阶段进行，第一阶段就是进行 var a 编译（在当前作用域代码执行前）； 第二阶段就是执行 a = 2（等待js执行到代码所在行）； 所以第一段代码真实的执行顺序是这样的： 123var a;a = 2;console.log(a); 第一阶段就是编译，第二阶段是执行；这就是 变量提升。类似地，第二段是这样处理的： 123var a;console.log(a);a = 2; 提升规则我们先来看看会进行提升的都有哪些，稍后再进行解释： 函数声明，函数声明优先级最高，忽略重复的变量和形参声明 形参，比变量声明优先，忽略重复的变量声明 变量声明 ※ 提升只会在其自身执行上下文中进行。什么？不知道执行上下文？下篇文章会介绍！ 形参12345function foo(a) &#123; console.log(a);&#125;foo(2); // 2 上面 foo 在执行时，会先进行 隐式的声明赋值 操作 var a = 2 ，然后在执行函数中的代码段；怎么证明呢？我们来改一下上面的代码： 1234567function foo(a) &#123; a = 3; console.log(a);&#125;foo(2); // 3console.log(a); // Uncaught ReferenceError 如果它没有这个隐式的声明，这里的 a 应该是全局变量（属性），函数体外就可以访问到。 因为它的这一特性,我之前一直以为形参和变量一模一样，只声明不赋值（其实默认赋值undefined），只不过执行时它的代码在函数体所有代码之上，后来发现其实不然。 形参声明的同时会接受实参的赋值，如果没有对应实参，赋值为undefined 。 123456function foo(a) &#123; console.log(a); function a() &#123;&#125;; &#125;foo(2); // function a() &#123;&#125; 如果按照我原先的理解，上面这段代码，在所有声明提升之后，执行 console.log(a); 之前会有一个 a = 2 的赋值，最后输出的就不会是 function 而是 2 。所以很明显，形参声明的同时就已经接收了实参的赋值，但优先级不高被函数声明覆盖了。 函数声明注意我们这里写的是 函数声明 ，不包含 函数表达式 。 12foo();function foo() &#123;&#125; 这一段代码可以正常执行，因为 foo 函数的声明已经被提升了。 1234foo(); // Uncaught ReferenceErrora(); // Uncaught TypeErrorvar a = function foo() &#123;&#125;;foo(); // Uncaught ReferenceError 上面这段代码可以看出来函数表达式不会让函数得到提升。而 a() 为什么会提示Uncaught TypeError呢，因为上面代码实际是这样处理的： 12345var a;foo();a();a = function foo() &#123;&#125;;foo(); // Uncaught ReferenceError 执行到 a() 的时候 a 还只是被默认赋值为 undefined ，并不包含对函数的引用。还要提到的一点就是，函数 foo 只能在其自身作用域内被发现。 函数声明比变量声明优先，忽略重复的变量声明 123456console.log(a); // function a() &#123;&#125; var a = 2;function a() &#123;&#125; console.log(a); // 2 上面第一个 console.log(a); 会输出 function a() {} 是因为函数声明优先，并且忽略了后面同名变量的声明。第二个 console.log(a); 输出 2 是因为执行代码时不会忽略初始化操作。代码的实际处理情况是： 12345678function a() &#123;&#125;// var a; 被忽略了 console.log(a); // function a() &#123;&#125;a = 2;console.log(a); // 2 如果是同名函数的声明则会对其进行覆盖，所以js没有函数重载。 练习123456var y = 1, x = y = typeof x;console.log(x);求上面代码段输出值; 答案1234567var y; // undefinedvar x; // undefinedy = 1;y = undefined;x = undefined;console.log(x); // undefined]]></content>
    </entry>

    
  
  
</search>
