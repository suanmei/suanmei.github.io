<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[重拾CSS规范之vertical-align]]></title>
      <url>%2F2016%2F10%2F11%2F%E9%87%8D%E6%8B%BECSS%E8%A7%84%E8%8C%83%E4%B9%8Bvertical-align%2F</url>
      <content type="text"><![CDATA[我经常需要让元素在垂直方向上对齐。 CSS 提供了很多可用的方法。有时候我用 float 解决问题，有时候使用 position: absolute ，而有些时候呢，甚至通过手动添加 margin 与 padding 这样污染代码的方式来实现。 我实在不喜欢这些解决方法。浮动元素仅在顶部对齐并且需要手动清除浮动。绝对定位使得元素脱离文档流，所以它们将再也无法影响周围元素。还有，使用固定 margin 和 padding 值的话，极小的改变都会立即破坏现有的布局。 但是，这里还有另一个角色： vertical-align 。我认为它应当受到重任。好了，确切地说，使用 vertical-align 来布局是一种 hack 行为，因为它不是为此而生。它用来排列文本和文本旁边的元素。尽管如此，你还是可以在不同的上下文中用 vertical-align 来灵活地、精细地排列元素。元素的大小并不需要知晓。元素会继续在文档流中，所以其他元素可以据此改变它们的尺寸。这些优势让它成为了有价值的选择。 vertical-align 的独特性但是，某些时候 vertical-align 是个十足的混蛋，用它解决问题可能会让人沮丧，似乎有一些难以理解的规则在起作用。比如，可能会出现这样的情况，你改变了 vertical-align 属性值的的元素压根没有改变对齐方式，但同一行的其他元素却有变动。我苦恼地撕扯着头发，仍不时地陷于 vertical-align 的死角。 不幸的是，大部分有关于 vertical-align 的资料都稍显粗浅，尤其是我们想藉此进行布局的时候。它们都集中精力在这样一个误区，试图让一个元素中的所有东西垂直对齐。它们给出了这个属性的基础介绍，以及在特别简单的情况下元素如何对齐，但并未解释棘手的那部分。 因此我给自己设立了一个目标，要一劳永逸地阐述清楚 vertical-align 的行为表现，最终通过研究 W3C 组织的 CSS 规范文档 并且演练一些例子完成了。成果就是这篇文章。 所以，就让我们来讨教一下这场游戏规则吧！ 使用 vertical-align 的条件vertical-align 被用来对齐 内联级元素 ，指这些元素—— display 属性计算值为 inline inline-block inline-table（本文中不作考虑） inline 元素基本上是包裹文字的标签。 inline-block 元素人如其名：披着 inline 外套的块元素。就像它拥有 padding 、 border 、 margin 一样，它同样可以拥有 width 和 height （可能由其自身内容所决定）。 内联级元素会在各行一个挨着一个排列开来，如果当前行有太多元素放不下的时候，新的一行会在它下面产生。所有这些行都拥有一个行盒，它包裹着该行所有内容。不同大小的内容意味着行盒拥有不同的高度。在下面的插图中，行盒的顶部和底部，都以红色线条表示。 这些行盒描绘出了我们可以作用的区域。在这些行盒中， vertical-align 属性的职责是对齐一些独立的元素。 那么问题来了，元素都是相对于谁来对齐的呢？ 关于基线和外边缘垂直对齐最重要的参考点就是所涉及元素的基线，某些情况下元素的盒模型的上下边缘也很重要。就让我们来看看涉及到的各个种类的元素的基线和外边缘在哪儿。 inline 元素 这里你可以看到相连文字的三条线，行高的上下边界用红色线条，文字的高度用绿色线条，基线用蓝色线条标注出来了。左边，文字行高被设置为文字大小的高度；中间，文字行高是文字大小的两倍；右边，文字行高是文字大小的一半。 行内元素外边缘 与它行高的上下边缘对齐，如果行高小于字体的高度也无所谓，所以，在上图中外边缘是红色线条。 行内元素基线 就是字符坐着的那条线，在图中是蓝色线条。严格来说，基线就是处在文字高度中间以下的某处。好好看看 W3C 规范寻求一下详细定义 。 inline-block 元素 从左到右你可以看到三个内联块元素，左边的包含着文档流内的内容（一个‘c’），中间的除此以外还添加了 overflow: hidden ，右边的没有文档流内的内容（但内容区域还有高度）。margin 边界用红色线条标注， border 用黄色， padding 用绿色，内容区域用蓝色。每个 内联块元素的基线是用一条蓝色线条展示的。 内联块盒的外边缘 是 margin 盒的上边缘和下边缘。他们在图中是红色线条。 内联块盒的外边缘 取决于元素是否拥有文档流内的内容： 在拥有流内内容的情况下，内联块元素的基线是最后一个流内内容元素的基线，这个元素的基线根据其自身规则来计算。（左边例子） 在拥有流内内容并且 overflow 计算值不是 visible 的情况下，基线是 margin 盒的下边缘。这样，它就和内联块元素的下边缘一样了。（中间例子） 在没有拥有流内内容的情况下，基线同样是 margin 盒的下边缘。（右边例子） line box 这种标注你们在上面就已经看过了，这次我同样画了行盒中文本框的上下边界（绿色）和基线（蓝色）。我还给文本元素设了灰色背景来高亮显示它们。 行盒的上边界与最高元素的上边界对齐，下边界与最低元素的下边界对齐。上图中红线标注的框就是。 行盒的基线 是可变的： CSS 2.1没有定义行盒基线的位置. — W3C 工作组 当我们使用 vertical-align 的时候，这可能是最让人疑惑的部分了。基线会被放置在任何需要的地方，用以达成像 垂直对齐 和 最小化行盒高度 的情况。它是等式中的自由变量。 行盒的基线是不可见的，它不能立马显示出它在哪里，但是可以很轻易地让它可见。在行的开头添加一个字符，比如我在例子中添加了’x’。如果这个字符没有以任何方式对齐的话，它将默认基线对齐。 行盒中，在基线周围有一个叫做 文本框 的存在。文本框可以被简单地当成行盒中的一个没有任何对齐方式的内联盒。它的高度等于它的父元素的字体大小。因此，文本框只包含行盒的非格式化文本，它在上图中被绿色线条标注。由于文本框与基线绑定在一起，当基线移动时它也移动。（这里所说的文本框在 W3C 工作组被叫做 strut ） 喔，这就是最难的部分，通过各个角度观察我们已经知晓了所有事情。让我们赶紧总结一下最重要的事实： 这里有个叫做 line box 的区域，在这里，会有垂直对齐。它拥有一条基线，一个文本框，以及上下边界各一条。 内联级元素，是会对齐的对象。它们拥有一条基线，上下边界各一条。 vertical-align 的值上面那个列表中最后一句话提及的参考点，因为 vertical-align 而有了关联。 元素的基线与行盒的基线 baseline：元素基线正好就在行盒基线上 sub：元素基线在行盒基线下方 super：元素基线在行盒基线上方 ：元素基线根据行盒基线位置移动 line-height * &lt;percentage&gt; ：元素基线根据行盒基线位置移动绝对的长度 元素的外边界与行盒的基线 middle：元素上下边界间的中心点对齐在行盒基线加上一半x-height 元素外边界与行盒的文本框 相对于该行框的基线对齐，我们还可以列出如下这两种情况，因为文本框的位置由基准确定。 text-top：元素上边界与文本框上边界对齐 text-bottom：元素下边界与文本框下边界对齐 元素外边界与行盒外边界 top：元素上边界与行盒上边界对齐 bottom： 元素上边界与行盒下边界对齐 当然，W3C 规范中就有 正式定义 。 为何 vertical-align 如此变现呢我们可以在特定的情境下近距离观察下垂直对齐，尤其是，我们在处理某些bug的情况下。 围绕一个图标一直困扰着我的一个问题是这样的：我有一个图标，我想让他紧邻一行文字居中对齐，我给它加上了 vertical-align: middle 但似乎没有以令人满意的方式居中。来看看这个例子： 1234567891011121314&lt;!-- left mark-up --&gt;&lt;span class="icon middle"&gt;&lt;/span&gt;Centered?&lt;!-- right mark-up --&gt;&lt;span class="icon middle"&gt;&lt;/span&gt;&lt;span class="middle"&gt;Centered!&lt;/span&gt;&lt;style type="text/css"&gt; .icon &#123; display: inline-block; /* size, color, etc. */ &#125; .middle &#123; vertical-align: middle; &#125;&lt;/style&gt; 这里我再次展示一下这个例子，不过我画了一些辅助线，上面已经讲过了。 它揭示出了我们的问题的一些情况。因为左边的文字压根没有对齐，实际情况是，使用 vertical-align 我们会把盒子对齐在没有延伸（1/2 的x-height）的小写字母的中心点。所以，有延伸的字符会伸出顶部。 在右边，文字与icon都对齐于一个中点，文字的基线稍微下移，位于行盒的基线的下方。结果是很好的达到了icon与文字对齐的效果。 行盒基线的移动当我们使用 vertical-align 时，都有这样一个坑：行盒基线的位置受该行所有元素的影响。假设，一个元素以某种方式对齐了，行盒基线受影响移动了，由于大部分元素都已经根据这条基线垂直对齐完毕，最后的结果就是其他所有的元素都需要调整位置。 一些例子： 一个很高的元素，其高度占满了整个行盒，那么 vertical-align 对其是没有影响的，在它的顶部和底部之外没有空间让其移动。但是为了满足它的对齐需求，行盒的基线会发生移动，左面的高元素的取值为 text-bottom ，矮元素的取值为 baseline 。右面的高元素的取值为 text-top ，你会看到基线跳上去了。 12345678910111213141516&lt;!-- left mark-up --&gt;&lt;span class="tall-box text-bottom"&gt;&lt;/span&gt;&lt;span class="short-box"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class="tall-box text-top"&gt;&lt;/span&gt;&lt;span class="short-box"&gt;&lt;/span&gt;&lt;style type="text/css"&gt; .tall-box, .short-box &#123; display: inline-block; /* size, color, etc. */ &#125; .text-bottom &#123; vertical-align: text-bottom; &#125; .text-top &#123; vertical-align: text-top; &#125;&lt;/style&gt; 当给高元素设置 `vertical-align` 为其他值时，会有同样的表现。 甚至将 vertical-align 设置成 bottom 和 top 也会移动基线，这很奇怪，因为不该波及基线。 12345678910111213141516&lt;!-- left mark-up --&gt;&lt;span class="tall-box bottom"&gt;&lt;/span&gt;&lt;span class="short-box"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class="tall-box top"&gt;&lt;/span&gt;&lt;span class="short-box"&gt;&lt;/span&gt;&lt;style type="text/css"&gt; .tall-box, .short-box &#123; display: inline-block; /* size, color, etc. */ &#125; .bottom &#123; vertical-align: bottom; &#125; .top &#123; vertical-align: top; &#125;&lt;/style&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之line-height]]></title>
      <url>%2F2016%2F09%2F16%2F%E9%87%8D%E6%8B%BECSS%E8%A7%84%E8%8C%83%E4%B9%8Bline-height%2F</url>
      <content type="text"><![CDATA[line-height 是为数不多支持数值可以带单位可以不带单位的属性，但是其效果确实千差万别，今天会用数据来侃一侃其中的差异性。前面讲 IFC的时候说过要好好聊一聊行盒的高度，就在本文中来个大揭秘吧。 前方高能提示，第一大节全部都是原理性的研究，不想看可以略过-_-但你会后悔的，后面是实用性比较强的知识。 定义二三事行高只能算是 line-height 的中文翻译， CSS 规范 只对 line-height 作出一个稍显模糊的定义。 line-height 值（即行高）就是两行（属性一样的）文本的基线的距离 两个不同字体或者不同大小的文字，它们的基线位置各不相同，基线距离根本就不能得出 line-height 值，这也是为什么我要强调属性一样的文字。 基线解释这里又要懵逼了，什么叫做基线？我怎么知道它在哪里？ 我们小学都用过英语四线三格纸，召唤一下它，唤醒我们内涵无限的童年。相信大家一看就知道这四条线分别代表哪个部分了。 line-height 高度机制谁 ‘撑开’ 高度当我们给一个空的 div 添加任意文字时， div 的高度会从 0 变成某一个值，那 div 是由文字 ‘撑开’ 的吗？不，是line-height的作用。 看一下我对下面两个 div 设置的 style ： 123&lt;div style="font-size: 40px; line-height: 0; border: 1px solid #ccc;"&gt;font-size: 40px; line-height: 0;&lt;/div&gt;&lt;br /&gt;&lt;div style="font-size: 0; line-height: 40px; border: 1px solid #ccc;"&gt;font-size: 0; line-height: 40px;&lt;/div&gt; font-size: 40px; line-height: 0; font-size: 0; line-height: 40px; 第一个 div 虽然字很大，但是由于 line-height 为 0 ，最后落得一个高度为 0 的结果;第二个 div 虽然 font-size 为 0 字儿都显示不出来了，但是愣是让 div 高度变为了 40px 。 所以， line-height ‘撑开’ 了匿名内联盒的高度，继而 ‘撑开’ 了 div 。如果我们平时开发，遇到想设置文字垂直居中，而设置 line-height = height 时，可以把 height 去掉了，因为 line-height 完全可以替代 height 的作用。 line-height 如何 ‘撑开’我们说是 line-height ‘撑开’ 了内联盒，其实不够准确。确实与 line-height 有关，但是它更像是一个指挥关，它后面还有一套时刻运转的机制来提供服务。 这里我想强调的是，基线之间的距离只是作为 line-height 的值，不代表 line-height 是这块区域的， line-height 是没有区域之说的，它就是一个值，一个概念。 内联盒真实的区域划分就是如上图所示，内联盒真正的组成就是由内容区域以及上下半行距组成。 顶线与底线之间的区域我们叫做内容区域，内容区域只与字体及字号相关，这个知道就行。上一行文本底线与下一行文本顶线之间的距离叫做行距，这个行距应当分成两半，上一行文本的下半行距，以及下一行文本的上半行距，我在图中在它们中间留了一条缝隙以示区分。 上半行距 + 内容区域 + 下半行距 = line-height 浏览器会根据字形来确定内容区域的高度 h，然后根据 (line-height - h) / 2 来计算出上半行距和下半行距。 如果我们定义了一行文本 line-height 为 30px ，假设内容区域高度为 16px ，那 上半距 = 下半距 = (30px - 16px) / 2 = 7px 。 其实，到了现在我们可以理解，为什么我们给单行文本设置了 line-height 之后，文本会垂直居中。但是，文本其实没有真正的垂直居中。因为真正垂直居中的是内容区域，而文字在内容区域中并不是垂直居中，通过上面的图就可以发现。但这一点不需要过度计较，因为这个平时压根看不出来。 行盒的高度我们平时可能听的比较多的版本是，行盒高度是由这一行中最大的 line-height 决定的，这句话其实是错的，因为它完全忽略了 vertical-align 存在的情况。 IFC 一问中已经讲到，行盒由一行内联级盒组成，行盒的高度就是最高的盒（上半边距）顶部到最低的盒（下半边距）底部的距离。 line-height各属性值来回顾一下 line-height 可设置的属性值类型： Value: normal | &lt; number &gt; | &lt; length &gt; | &lt; percentage &gt; | inherit Tips：不可以对 line-height 设置负值！ normal 没什么太多可讲的，这是 line-height 的默认值。它实际表现等同于 1.1 ~ 1.2 number 指不带单位的数值。它的计算值是 line-height 乘当前元素的 font-size 假设我现在指定 font-size: 20px; line-height: 1.2; ， line-height 最后实际值为 20px * 1.2 = 24px length 就是直接指定带单位的值，如 px , em percentage 就是指百分比。它的计算值是百分比乘当前元素的 font-size inherit 因为浏览器实现方式差异较大，故不推荐使用 然后我就在想， line-height: 1.2 和 line-height: 120% 最后计算值都是一样，那为什么要设置两种方式呢？存在必有原因。 最重要的一点：line-height: 1.2 继承给子元素的是 line-height: 1.2 ，而 line-height: 120% 是先将 line-height 计算出来，再将此计算值继承给子元素。 line-height 为 0line-height 为 0 ，公式 上半行距 + 内容区域 + 下半行距 = line-height 依然成立，设内容区域高度为 h ，此时上下半距都为 -h/2 。但是文本在页面中是不会占据任何空间的。 图片底边距这里说个题外话。。。 line-height 对 img 是不起作用的，但是对同样是可替换元素的 input 却能起到作用，这是为什么呢？后来我想了想，是有原因的，因为 line-height 只能对文本起作用， input 里面是有可以文本的，而 img 中却不可以，同样 object 也是一样。 good luck 瞪大双眼看一看，图片底边与 div 底边并没有完全贴合，还有一个很小的间隙，这个其实是 line-height 与 vertical-align 共同作用带来的影响。 原因探析img 默认是 baseline 对齐，看一下图示。 红色的线是基线，绿色的线是底线，底线距离 div 底边还有很小的一点距离，就是下半边距。 我们的文字产生的匿名内联盒自然也是有高度的，基线以下的部分也得显示出来，所以图片下方边距，正是 文本基线到底线的距离 + 下半边距 。div 的高度就是它所产生的包含块的高度，就是行盒的高度总和（此例中只有一行，所以等于该行盒高），就是 图片高度 + 文本基线到底线的距离 + 下半边距 。 html5 带来的变化在 html4 中，如果没有文字则自然没有上面所说的图片底边距问题，但是情况在 html5 有了变化。 即使没有文本，图片也会当做它身边有文本存在，此时它会带来两种与 html4 不一样的表现。 永远存在图片底边距问题 如果图片高度低于文本高度， div 高度依旧等于文本高度 解决方法 div 设置 line-height: 0 或者 font-size: 0文本不占据空间，自然不会凸出来了。但是这个方法显然没有那么美妙，万一我有文字需要添加呢，是吧 img 设置 vertical-align: bottom让图片与行盒底部对齐，这样子文字就不会有一部分凸出来了。 img 设置 display: block 或者 float: left变成了块盒自然就没有基线对齐这些事了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之overflow]]></title>
      <url>%2F2016%2F09%2F15%2F%E9%87%8D%E6%8B%BECSS%E8%A7%84%E8%8C%83%E4%B9%8Boverflow%2F</url>
      <content type="text"><![CDATA[overflow 的知识点没有那么多，所以这篇文章里面概念性的东西只放了一个，干货实例反而很多，而且都是很多我们平时都必须要用的，也有一些可能容易被忽略的知识点本文都有提及。所以，不要没有耐心，这里都是你的菜！ 当然文章也从来不是科普文，了解 overflow 基本概念就点击 CSS overflow 。 常识拓展浏览器滚动条的来历我们都看过浏览器的滚动条，那浏览器的滚动条是从哪儿来的？答案是 html 而非是 body ，这里就不再去给例子论证了。 那IE7和之前的浏览器右边会一直存在一条滚动条，即使没有滚动。IE8开始，还有其他的浏览器却不是，那造成这一切的源头是什么呢？我们来看一下浏览器默认样式。 IE7浏览器默认： html { overflow-y: scroll; } IE8+浏览器默认： html { overflow: auto; } overflow-x/overflow-y只设置一个如果 overflow-x 和 overflow-y 值不同，且其中一个值显式设置为 visible 或未设置而默认为 visible ，而另外一个值是非 visible 的值，则 visible 值会被重置为 auto 。 按常理来说，我只给 overflow-x 设置了 auto ，那应该只生成横向滚动条。但恰恰是因为上面指出的特性， .wrap 元素的 overflow-y 也由 visible 变为了 auto 。 padding-bottom的缺失现象Chrome 支持，其他浏览器不支持 padding-bottom 。 在不同浏览器打开我的博客查看即可。 所以以后想添加这种效果或者计算滚动高度的时候要注意各个浏览器的兼容性。 JS计算页面滚动高度 Chrome 浏览器： document.body.scrollTop 其他浏览器： document.documentElement.scrollTop 所以如果想要获取页面滚动高度，推荐这样写： var st = document.body.scrollTop || document.documentElement.scrollTop 水平居中跳动问题我们是不是遇到过这么一种问题，本来页面高度不超过屏高，页面是没有滚动的，但是有一个展开的功能，把页面撑开了，滚动条就出来了。假设页面最外面的包裹元素是 .container 元素，它定宽且水平居中。在滚动条出现的这一刹那，它一定会被挤，向左偏移。因为是一下子偏移过去的，会有页面跳动的感觉。 解决方法有两个： html { overflow-y: scroll; } 这样子又回到了IE7年代了，很不推荐 .container { padding-left: calc(100vw - 100%); } 这样子就不会出现偏移跳动了，但是此时就算不上居中了。 自定义滚动条样式这里给出的是 webkit 内核的浏览器定义方式，IE的太丑就不介绍了。 123456::-webkit-scrollbar /*整体部分*/::-webkit-scrollbar-button /*两端按钮*/::-webkit-scrollbar-track /*外层轨道*/::-webkit-scrollbar-track-piece /*内层轨道*/::-webkit-scrollbar-thumb /*滚动滑块*/::-webkit-scrollbar-corner /*边角*/ 实际开发常用的就下面几个： 123456789101112::-webkit-scrollbar &#123; /*滚动条宽高*/ width: 8px; height: 8px;&#125;::-webkit-scrollbar-thumb &#123; /*滚动滑块*/ background-color: rgba(0,0,0,.3); border-radius: 6px;&#125;::-webkit-scrollbar-track &#123; /*轨道背景*/ background-color: #ddd; border-radius: 6px;&#125; absolute 溢出 我勒个擦，不是已经设置了 overflow: hidden 了吗，怎么还能出去？绝对定位要上天了。。。 先找一下相关的官方解释： 绝对定位元素不总是被父级 overflow 属性裁剪，尤其当 overflow 在绝对定位元素及其包含块之间的时候。 【包含块】：此处的包含块指 position 不为 static 的元素 哦，原来是这样， overflow 确实在绝对定位元素及其包含块（根元素）之间，所以压根管不住他。 有问题就得解决问题啊！下面提供两种方法来解决这种问题。 解决方法 overflow 元素自身为包含块 overflow 元素和绝对定位元素 中间的元素为包含块 设置非 static 的 position 即可。 实际案例下面是前两天leader要我们解决的一个案例的简化版。真实案例中，滚动窗中是一个表格，每一行中都有一个待提示字段，但是leader希望能够让出现的提示文本悬浮在滚动窗之上。 反正我到现在没找到实现的可能性，因为如果去除 relative ， 绝对定位元素将会跑到滚动窗外边去，不去除 relative ，就一定会被限制在里面。昂，就是无解喽！ 配合 overflow 才能实现的效果resize 拉伸 必须配合非 visible 的 resize 才能实现。 文字溢出以 ‘…’ 显示 之前讲解 BFC 的时候，详细分析了它的各项特性， overflow 恰恰能够触发它，所以如果记不太清就赶紧回去翻翻看昂。 今天还找到了一种比较好的写博客的方法，一边学习的时候一边在新建文件中写下来，写博客的时候一是方便整理思路，而是省去了一些重复劳动力，速度上去了好多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之z-index]]></title>
      <url>%2F2016%2F09%2F13%2F%E9%87%8D%E6%8B%BECSS%E8%A7%84%E8%8C%83%E4%B9%8Bz-index%2F</url>
      <content type="text"><![CDATA[What’s z-indexz-index 会为当前的盒创建层叠上下文，也会指定该盒在父级层叠上下文中的层叠等级。 What the fuck！ 怎么越说越乱！什么是层叠上下文？什么是层叠等级？ 一个页面我们平时看到的是平面的，我们感觉它就是一个水平面（二维）的东西。但是为什么元素互相之间覆盖，这就说明，它们在垂直方向上是有顺序的。一个盒创建了层叠上下文，就是给它自己划了一片自治区，下面的盒无论是排资论辈，抑或是创建了层叠上下文，都只能在这片区里面待着。 定位（position 不为 static）的盒和flex盒的子元素都会有一个层叠等级，这个层叠等级就是 z-index 值，默认值 auto 我们可以理解为 0 。这就是为什么其他的没有层叠等级，因为 z-index 对它们无作用。层叠等级就是用来排资论辈的，等级高的在上面，等级低的在下面。但是，同一父级层叠上下文的层叠等级才有意义。 层叠等级只需要理解就好，真正的重点是层叠顺序。 层叠顺序 页面中所有元素都脱离不开这张七阶图，有了它我们可以知道所有元素在z轴上的先后顺序。图中越是靠前的元素，它离我们的眼睛越近，覆盖其他元素的能力就越强。七阶层叠图示中的层叠顺序指的是同一层叠上下文中的元素的层叠顺序。 当然，这里还有两点需要补充一下： z-index越大，越靠前，这就是用层叠等级来排资论辈的。 层叠顺序、层叠等级（如果有的话）相同的两个元素，后面的会覆盖前面的。 上面以及后面要讲的 “靠前” 就是z轴上越高，层叠顺序也越高。 极易混淆易错点子层叠上下文无法比父层叠上下文低我们有时候会希望让子元素居于父元素下方，我们可能会立即想到给子元素设置一个比父元素更低的z-index，结果肯定得不到我们希望的效果。 !--https://jsfiddle.net/y4cta1m4/-- 回顾一下层叠七阶图，会发现，父层叠上下文的 background 处于第一阶，而子层叠上下文 z-index 为负，处在第二阶，子层叠上下文的层叠顺序在父层叠上下文之上！！！它们是父子层叠关系，不是兄弟层叠上下文，所以不能通过 z-index 来比较它们的层叠等级。 那如何才能让子元素在父元素之下呢？让父元素不产生层叠上下文，并且让子元素 z-index 为负就可以了。 层叠上下文不关心父子元素关系，它只关心父子层叠上下文。 不同上下文中的元素的比较不取决于自身上面那句话可能看着拗口不好理解，那我们看一下下面的例子辅助理解一下。 我们可以看到 .inner1 元素的 z-index 设置到了 9999 ， .inner2 元素的 z-index 设置到了 0 ，但是后者就是覆盖了前者，为什么呢？为什么呢？ 我们前面说了，元素层叠顺序只能够在自身所处的层叠上下文中比较，那和其他上下文中的元素怎么比较呢？拼爹!!! 这确实是一个很有意思的词，我来解释一下，就是说，处于同一层叠上下文的 A,B 两个元素，它们都创建了各自的层叠上下文，如果 A 层叠等级高于 B ，那么 A 下面的所有元素在z轴上高于 B 下面的所有元素。 z-index:auto;与z-index:0;的异同我们下面会介绍哪些元素会创建层叠上下文，但是不代表能够创建层叠上下文的元素就可以显式地设置 z-index 。这些元素中不能设置 z-index 的，他们最后的表现其实就是 z-index:auto; 。 那 z-index:auto; 和 z-index:0; 的相同之处在于，计算层叠等级的时候指定为 auto 的 index 实际计算值就是 0 。不同之处在于， z-index:auto; 不能创建层叠上下文，但是 z-index:0; 却可以。 position:relative; 元素默认 z-index:auto; ，根据我们之前论证出来的，子层叠上下文无法比父层叠上下文低。上面的例子表明， z-index:auto; 并不能创建层叠上下文。但是有个例外， position:fixed; 元素可以创建。 哪些元素可以创建层叠上下文我们在这里呢，把它们分成两部分，第一部分是 CSS2.1 中定义的可以创建的，第二部分是 CSS3 中新增的。 CSS2.1 中规定的 根元素 HTML z-index 不为 auto 的定位元素——实际情况有出入，z-index:auto;与z-index:0;的异同 一节已经讲了 CSS3中新增的 z-index 值不为 auto 的 flex 项(父元素 display:flex|inline-flex) 元素的 opacity 值不是 1 元素的 transform 值不是 none 元素 mix-blend-mode 值不是 normal 元素的 filter 值不是 none 元素的 isolation 值是 isolate will-change 指定的属性值为上面任意一个 元素的 -webkit-overflow-scrolling 设为 touch 这里除了 flex 项，其他的都不能设置 z-index ，实际表现就是 z-index:0;。 z-index 平时真是被我们滥用了，有时候为了做一个弹出层效果，就随便设置一个 z-index:9999; ，这是一个坏习惯，所以我们要尽可能的利用层叠顺序规则来更规范地实现效果。 小小的一个属性牵扯了这么多内容，深入理解CSS，下节更精彩。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之BFC & IFC]]></title>
      <url>%2F2016%2F09%2F06%2F%E9%87%8D%E6%8B%BECSS%E8%A7%84%E8%8C%83%E4%B9%8BBFC%26IFC%2F</url>
      <content type="text"><![CDATA[BFC、IFC的概念重要吗？不重要，没有它们我们也能写出符合要求甚至很好的页面。重要，深入了了解了CSS这门语言的核心，你的CSS才可能会有创造性，你才能发明出你自己的奇淫技巧，而不是遇到新的情境就去百度，google。 在看这篇文章之前，先得了解一些无聊的基本概念，重拾CSS规范之从盒类型谈起，当然，我已经尽可能让它有趣了。 FCFC（Formating Context，格式化上下文） 是一个布局的环境，它里面的盒子需要遵循FC这套体系的规则， CSS2.1 中定义了 BFC（Block Formating Context，块级格式化上下文） 和 IFC（Inline Formating Context，内联格式化上下文）， BFC 讲的是块级盒子的布局规则， IFC 讲的是内联级盒子的布局规则。 BFC脱离特性讲定义都是流氓！！！光看个定义不好使，赶紧来捋一捋 BFC 的家规吧。 1. 浮动，绝对定位元素，非块盒的块容器（例如，inline-blocks，table-cells和table-captions）和’overflow’不为’visible’的块盒会为它们的内容建立一个新的块格式化上下文。 这里只说明了一点： 如何触发BFC！（很重要啊，多练多记忆，一定要熟稔于心） 2. 在一个块格式化上下文中，从包含块的顶部开始，盒在竖直方向一个接一个地放置。两个兄弟盒之间的竖直距离由’margin’属性决定。同一个块格式化上下文中的相邻块级盒之间的竖直margin会合并。 关于 margin 合并的问题，我在这篇文章里面已经描述的很详细了：重拾CSS规范之margin 透过下面的DEMO来看看如何阻止 margin 合并： margin 一文中 margin合并规则 中写到了这么一句话，新建了块格式化上下文的元素不会与它的子元素的 margin 合并，所以 .wrap 元素就不会合并 .first 元素的 bottom margin 了，也就无法与 .second 元素发生 margin 合并了。 而且我们可以发现， BFC 就是一个密闭的容器 ， BFC 里面的元素无法对外界元素在布局上产生直接的影响。（为什么我要用‘直接’呢，因为它完全可以撑开 BFC 元素，来‘挪动’外界元素的位置） 那我们再考虑一个问题， 产生了新的 BFC 的盒会与它的兄弟盒产生 margin合并 吗？ 当然是会的。 3. 在一个块格式化上下文中，每个盒的left外边挨着包含块的left边（对于从右向左的格式化，right边挨着）。即使存在浮动（尽管一个盒的行盒可能会因为浮动收缩），这也成立。除非该盒建立了一个新的块格式化上下文（这种情况下，该盒自身可能会因为浮动变窄） 这里主要涉及到的就是多栏自适应布局的应用了。 如果要控制两者之间的间距，最好对 .left 元素使用 margin-right 。因为如果对 .center 元素使用 margin-left 的话，首先 margin-left 值必须要超过 .left 元素的宽度值，否则无法体现作用；再者对 .center 元素设置 margin-left 了，不就又回到了流体自适应布局了吗！ 4. 在计算生成了 BFC 的元素的高度时，其浮动子元素应该参与计算。 几年前我技术很差的时候总在疑惑，float元素没法撑开父元素高度，但是为什么给父元素增加设置不为 ‘none’ 的 ‘float’ 值就可以了，现在总算是解开谜题了。。。 IFC上一篇文章中已经提到了很多 IFC 相关的知识，这次再补充一点。 IFC 中的盒子与 BFC 中的不同的是，它们可以水平依次放置。 IFC中的行盒的宽度是包含块的宽度减去 float 元素（如果有的话）的宽度，行盒高度是最高的盒的top与最低的盒的bottom之间的距离。 内联盒的高度是由line-height决定的，而可替换元素，inline-block，inline-table 元素的高度则是由它们的 margin 盒高度决定的。 关于行高的计算后面会有较大篇幅的文章来介绍，敬请期待！ ‘display’，’position’与’float’之间的关系如果’position’值为’absolute’或者’fixed’，或者’float’值不为’none’，或者该元素是根元素，那么display就根据下表来设置。 同时设置’absolute’或者’fixed’、非 ‘none’ 的 float，float 会被覆盖为 ‘none’。 指定值 计算值 inline-table table inline, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, table-caption, inline-block block 其它 与指定值相同]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之从盒类型谈起]]></title>
      <url>%2F2016%2F09%2F02%2F%E9%87%8D%E6%8B%BECSS%E8%A7%84%E8%8C%83%E4%B9%8B%E4%BB%8E%E7%9B%92%E7%B1%BB%E5%9E%8B%E8%B0%88%E8%B5%B7%2F</url>
      <content type="text"><![CDATA[今天要写的不是CSS标准盒模型和IE盒模型，那个烂大街了。今天要深入探讨的是CSS去控制页面布局背后的那一套规则，页面就是由很多个各式各样的盒组成的，那我们就聊这个。这个是对后面的BFC以及定位模式的一个铺垫，基础很重要！！！ 术语普及 盒： 每个元素都会生成一个盒，用来容纳后代（生成的盒）和自己生成的内容(比如说一段文字)。所以我们可以把一个页面看做是由一个个的盒子堆砌而成的，只是这些盒子也分种类，就像这个社会在视觉上由男人和女人构成。块级元素： display 为 block/table/list-item 的元素。块级盒： 块级元素生成的盒块容器盒： 块级盒同时也是块容器盒，除了表格盒与可替换元素。顾名思义，块容器盒就是它要容纳后代和它自身的内容。这里面我发现了一个很有趣的事儿，可替换元素，所以它们都是通过 value/src 之类的属性来控制内容显示，可能正是因为它们 无法添加后代元素 的特性所以才不算是块容器盒的。内联级元素： display 为 inline/inline-block/inline-table 的元素。内联级盒： 内联级元素生成的盒。但是只有 inline 元素生成的盒才叫做内联盒，它区别于 inline-block 元素的内联级块盒。行盒： 内联格式化上下文中，包含来自同一行的盒的矩形区域叫做行盒可替换元素： 浏览器根据元素的标签和它的属性来决定元素的具体显示内容。比如 &lt;img&gt; &lt;input&gt; &lt;textarea&gt; &lt;select&gt; &lt;object&gt;。 内联元素的一个小特性这里单独把内联元素给拿出来了，内联元素必须要区别于内联级元素，内联元素只是指 diaplay 为 inline 的元素。 margin-top,margin-bottom 对内联元素无效。padding-top,padding-bottom 对内联元素有效，但它们不能对布局产生任何影响。 上面第一句话比较容易理解，第二句话可能需要通过例子辅助理解。 上图中 padding-top 和 padding-bottom 会影响到块级元素 content 区域位置，会让块级元素的空间真正意义上的变大，进而影响其他元素的位置。但是再看内联元素这边，我们可以看出来 padding 确实存在，但是它没有起到任何影响，没有能够让内联元素占据的空间变大，布局上没有对元素自身起到任何影响，更别提对其他元素产生影响了。可能唯一的作用就是设置 background 的时候， padding 能起到作用。 匿名盒CSS为了方便布局，它规定：一个块容器盒要么只包含块级盒，要么只包含内联级盒。 匿名块盒我们来看看CSS会如何对待这段代码： 12345&lt;div&gt; &lt;span&gt;我是span内的文字&lt;/span&gt; &lt;p&gt;我是p内的文字&lt;/p&gt; 我是没有任何标签包含的文字&lt;/div&gt; 大家好，我是 div ，我是一个块容器盒，我发现我的儿子 p 生成了块级盒，那么我其他的儿子也必须都是块级盒。sorry， span 龟儿子，麻烦你变个身，变成块级盒。卧槽，’我是没有任何标签包含的文字’ 这段文本不太好处理啊，他又不是我儿子，不好直接命令他。 幸好老子灵机一动，要不我干脆认他做个干儿子。 div：“文本小孩儿，你愿意做我的干儿子吗？” 文本：“我愿意，爸爸！” div：“真是个好孩子。但是呢，今天这情况，你们都必须要有一个块级盒，你其他的哥哥们自己会生产，看你小子啥也不会，爸爸就送你一个吧，不过这个盒子无名无分，我们就叫它匿名块盒” 准备工作都做好了，再来看看他们家的家谱吧！ 我们可以看到，上面 span 也变成块级盒了，那我们是不是像对待块级元素一样给它设置宽高呢？当然不能！！！所以说，上面的图片是错误的！！！ 其实呢， span 这小子作弊了，它明明只是猴子派来的逗逼，当然不能像猴子一样变身，那层块级盒（block box）是它老爸发放的作战物资——匿名块盒。所以呢，真实的情况是：它自己本身只能产生内联盒，然后在它外面还会包裹着一个匿名块盒。 那我们来看一看正确的家谱： 正是因为匿名盒的存在， span 和那段小文本也能够像块级元素一样，单独占据一整行。 那再有一个问题，几个内联元素在一起，它们明明是同一行排列啊，并没有像块级元素一样换行显示。其实呢，多个内联元素在一起，匿名块盒会把相邻的内联盒“打包”，一起包裹起来。 匿名内联盒任何被直接包含在一个块容器元素中（不在一个内联元素里面）的文本，必须视为一个匿名内联元素。 再来看一段代码： 1234&lt;p&gt; &lt;span&gt;我是span中的文字我是span中的文字我是span中的文字&lt;/span&gt; 我是没有任何标签包含的文字&lt;p&gt; 大家好，我是 p 元素，我今天看了看我的儿子们，不容易啊，一个块级盒也木有昂，按照CSS当年定下的规矩，这样的情况下，本王必须建立内联格式化上下文（IFC）来安置这群傻孩子。 span 好说啊，自己本身就生成了内联级盒，麻烦的就是这个没有任何标签包围的文本了。咱们还用老方法行不行(⊙v⊙) p：“文本小孩儿，你愿意做我的干儿子吗？” 文本：“我愿意，爸爸！” p：“真是个好孩子。但是呢，今天这情况，你们都必须要有一个内联级盒，你其他的哥哥们自己会生产，看你小子啥也不会，爸爸就送你一个吧，不过这个盒子无名无分，我们就叫它匿名内联盒” 闲话不多说，看家谱： 我们可以看到如果一个行盒无法容纳下某个内联盒，这个内联盒就会分割开来放在多个行盒中。注意一下在换行（分割）的地方，是没有竖直线的，表示内联盒未结束，而且 margin,padding 值在这里是不会体现出来的， margin-left,margin-right,padding-left,padding-right 值只存在于内联盒的开始和结束的地方。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重拾CSS规范之margin]]></title>
      <url>%2F2016%2F07%2F30%2F%E9%87%8D%E6%8B%BECSS%E8%A7%84%E8%8C%83%E4%B9%8Bmargin%2F</url>
      <content type="text"><![CDATA[好久没写博客了，甚是惭愧啊，md语法都快忘了。最近一直在忙着巩固基础，实在是厌倦那种似懂非懂的感觉。有的时候bug出来了，拿别人的代码可能一下子就解决了，可是知识面太零碎化。这篇文章不会涉及margin基本属性，因为这些网上都有。本文内容量不会特别大，但是里面的知识点很多人在实际开发中却会混淆。 margin有效性 margin对 display:table; 系列（这其中不包含 table-caption， table 和 inline-table） 以外的所有元素有效 margin-top 和 margin-bottom 对不可替换的内联元素无效 margin百分比值百分比根据生成盒的包含块的width来计算。 我们来看看关于包含块的几种情况： 如果该元素的position是 relative 或者 static，包含块由其最近的块容器祖先盒的content边形成 如果元素具有 position: fixed，包含块由连续媒体的视口或者分页媒体的页区建立 如果元素具有 position: absolute，包含块由最近的 position为 absolute，relative或者 fixed 的祖先建立，按照如下方式： 如果该祖先是一个内联元素，包含块就是环绕着为该元素生成的第一个和最后一个内联盒的 padding box 的边界框。 否则，包含块由该祖先的 padding 边形成 margin auto探讨我们是否有想过一个有固定宽度的div元素设置了 margin: auto; 为什么可以水平居中显示？为什么有固定高度却无法垂直居中显示？ why can 水平居中常规流中的块级不可替换元素的规则中包含这样两个规则： ‘margin-left’ + ‘border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ + ‘border-right-width’ + ‘margin-right’ = 包含块的宽度 如果’margin-left’和’margin-right’都是’auto’，那么它们的应用值相等。 举个栗子，假设 div 设置了固定宽度, padding 和 border 为零，当我们设置 margin: auto; 时，浏览器会设置 margin-left 等于 margin-right，并且解方程组求出正确的margin-left 和 margin-right 值。 只要常规流中的div有固定宽度，并且 padding 和 border 左右两边的数值大小一样，设置了 margin: 0 auto; 就能让其水平居中显示。 why can’t 垂直居中CSS2.1规范文档10.6.3节指出： ‘overflow’ 计算值为 ‘visible’ 时常规流中的块级不可替换元素 如果’margin-top’或者’margin-bottom’为’auto’，其应用值为 0。 所以说，管你有没有设定高度，你都会把你的 margin 上下值设置为 0。也就是垂直方向上 div 原地不动！ What else can 水平/垂直居中 by ‘margin: auto’除了本节的第一种情况外，还有一种情况，那就是 绝对定位元素 。 它不仅能够水平居中，同样能够垂直居中。 上面 top/bottom/left/right 我都设置的 0 ，当然也可以设置成非零元素，只需要让数值两两对称就行了，但是这样不够安全。举个栗子，有人作死，top/bottom 的值放得太大了，top + bottom + height + border + padding 超过了 包含块的高度，那咋办呢？？？ margin 不就要变成负值了吗？？？ 不会的，这时候，浏览器会忽略 bottom 值， margin-top/margin-bottom 置 0，根据方程式重新计算合适的 bottom 值，而我们里面的 div 就不会垂直居中了，它会根据 top 来定位。 所以么，能不作死就不要作死了，上面的代码示例又方便又安全。 margin合并margin合并也可以叫做外边距叠加，这是一个简单的概念，指的就是两个或者多个盒的相邻的margin可能会合并在一起。如果还不能理解的话，我们用图示来理解一下。 当一个元素出现在另一个元素上面时，第一个元素的底外边距与第二个元素的顶外边距发生叠加。 当一个元素包含在另一个元素中时，它们的顶外边距或者底外边距也会发生叠加。 甚至外边距还能与自身进行叠加。如果一个空元素，上下方向有外边距，但没有边框和内边距，这时候，上下外边距就会相遇，自然而然的叠加了。 如果这个外边距又遇到了其他元素的外边距（margin相邻），它们还能继续叠加。 O__O “…看来margin的世界里也会有小三小四的存在。 那我们有没有想过 CSS 工作组为什么会设立这么一个 bug 般的存在！这是为了服务段落元素 p 啊。 我们常见的段落与其他元素都会有间距，这是因为，用户代理给他们设置了默认margin值。可那为什么两个段落相遇，间距却没有拉大呢？这就是用到了我们上面所说的前后两个div，它们的底外边距和顶外边距叠加在一起了，共享一个外边距，自然就不会拉大了。 不是所有相邻的margin相邻都可以合并！！！ margin合并规则 水平方向的 margin 不会合并 一个浮动的盒与任何其它盒之间的 margin 不会合并（甚至一个浮动盒与它的流内子级之间也不会） 建立了新的块格式化上下文的元素（例如，浮动盒与 ‘overflow’ 不为 ‘visible’ 的元素）的 margin 不会与它们的流内子级合并 绝对定位的盒的 margin 不会合并（甚至与它们的流内子级也不会） 内联盒的 margin 不会合并（甚至与它们的流内子级也不会） 一个流内块级元素的 bottom margin 总会与它的下一个流内块级兄弟的 top margin 合并，除非兄弟有空隙 一个流内块级元素的 top margin 会与它的第一个流内块级子级的 top margin 合并，如果该元素没有 top border ，没有 top padding 并且该子级没有空隙 一个 ‘height’ 为 ‘auto’ 并且 ‘min-height’ 为 0 的流内块级盒的 bottom margin 会与它的最后一个流内块级子级的 bottom margin 合并，如果该盒没有 bottom padding 并且没有 bottom border 盒自身的 margin 也会合并，如果 ‘min-height’ 属性为 0 ，并且既没有 top 或者 bottom border ,也没有 top 或者 bottom padding ，并且其 ‘height’ 为 0 或者 ‘auto’ 当两个或者更多的 margin 合并时，产生的 margin 宽度为合并 margin 宽度中的最大值。至于负 margin ，就从正相邻 margin 的最大值中减去负相邻 margin 的绝对值的最大值。如果没有正 margin ，就用 0 减去相邻 margin 的绝对值的最大值。 margin常见bugIE6双边距bug场景： 当给父元素内第一个浮动元素设置 margin-left 或 margin-right 时 margin 加倍。解决办法：给第一个浮动元素设置属性 display:inline; IE6中3px偏移bug场景： 当一个非浮动元素与一个浮动元素相邻时，他们之间会多出 3px 的间隔。如果非浮动元素没有设置高度，将使非浮动元素中的内容与其多出 3px 间隔，如果设置了高度，则是 div 之间多出了 3px 间隔。解决方法： 设置非浮动元素 float:left; 一起浮动；或者为右边元素添加 IE6 Hack——为非浮动元素设置高度 _min-height:1%;。这时文本3px偏移会消失，但时候出现元素盒偏移，只需要再为浮动元素设置 _margin-right:-3px;就可以了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之this]]></title>
      <url>%2F2016%2F06%2F14%2FJavascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E4%B9%8Bthis%2F</url>
      <content type="text"><![CDATA[这篇文章其实几天前就想写了，但是近日又看到了 this 的很多用法，诸如硬绑定、软绑定，都没用到过。所以不禁感慨，学无止境啊。 this 根据情境不同，指向性差异很大，所以今天就是进行一个简单的梳理，并且对其进行一些原理性的分析。 前言关于this的误解有很多，有人认为 this 指向函数自身，有人认为 this 指向函数上一级，诸如此类的太多了,甚至就连《高程》中对其都有一个不太严谨的描述： 在全局函数中， this 等于 window ，而当函数被作为某个对象的方法调用时，this 等于那个对象。 今天我们就来探讨一下this的正确打开方式。 What’s this前一篇文章中提到过， this 是执行上下文的一个属性，它不是一个变量，所以我们不能对其进行赋值操作，否则会报错；同时 this 属性是在函数调用时才确立的，它与函数如何定义没有任何关系，它只能决定于它的调用方式。 那今天的重点就是讨论几种调用方式了？当然不是，重点就是了解一下 this 是如何来寻找指向对象的，这里就要引出我们的 引用类型 了。 引用类型引用类型有两种情况：标识符和属性访问器。在处理引用类型的时候，会返回一个引用类型值，我们用伪代码来表示一下： 12345678var reference = &#123; // 拥有这个属性的对象 base: &lt;base Object&gt;, // 引用名 referenceName: &lt;reference name&gt;, // 严格模式标记（boolean） 后面省略这个属性（不太用得到） strictReference: &lt;strict flag&gt;&#125; 举个栗子： 1234var obj = &#123; bar: function () &#123;&#125;&#125;;function foo() &#123;&#125; 在调用的中间结果中，返回了如下的引用类型的值： 12345678var barReference = &#123; base: obj referenceName: bar&#125;;var fooReference = &#123; base: global, referenceName: foo&#125;; 到了这里，准备工作已经做好了，下面就是 this关联规则 粉墨登场了。 在一个函数上下文中，先判断调用括号 () 的左边是否为引用类型， 如果不是则将 this 设置为 undefined ， 如果是，再判断引用类型是否为属性引用，如果不是则将 this 设置为 undefined ，如果是，则将 this 设为引用类型值的 base 对象。如果 this 的值为 undefined ，其值会被隐式转换为全局对象；而如果在严格模式下，undefined 不可以被隐式的转换 。 下面我们就要通过具体的几个情景来看一下关联规则是如何具体运作的。 独立函数调用独立函数的调用我这里将它分为独立全局函数调用和独立内部函数调用，什么叫做独立呢，就是直接调用，不显式依托对象。 独立全局函数调用先看看一个简单的例子： 1234function foo() &#123; console.log(this);&#125;foo(); // window (global对象无法直接访问) 让我们来分析一下上面的代码产生了什么引用类型值： 1234var fooReference = &#123; base: global, referenceName: foo&#125;; 如果在非严格模式下， this 会指向全局对象（ global 对象无法直接访问，但是 global 的 window 属性引用了 global ，所以上面会输出 window ）。但是在严格模式下， this 值将被设为 undefined 。 123456function foo() &#123; "use strict"; console.log(this);&#125;foo(); // undefined 严格模式与函数调用位置无关，只与函数定义有关。当然，如果你是全局使用严格模式，就不必考虑它了。 123456789function foo() &#123; console.log(this);&#125;(function()&#123; "use strict"; foo(); // window&#125;); 独立内部函数调用内部函数就和全局函数虽然名字很近似，但他们却有本质上的区别。哈哈，这里就不卖关子了，先来看代码： 123456789function foo() &#123; function bar() &#123; console.log(this); &#125; bar();&#125;foo(); // window 这里呢， foo() 内 bar() 最终输出 window ，这是为什么呢！！！ 是这样的，我们来看一下上面代码产生的引用类型的值： 1234var barReference = &#123; base: AO(fooReference), referenceName: bar&#125;; 这里的 base 被绑定了 foo 函数活动对象，可是函数调用并不是属性调用，所以根据上面的规则， this 被赋值为 undefined ，并隐式地转换为全局对象。 关于引用类型的base对象以及属性名是怎么寻找的，以及什么时候寻找的，将在作用域那一篇文章中进行介绍。 方法调用我们拿个栗子边吃边聊： 1234567var obj = &#123; foo: function() &#123; console.log(this); &#125;&#125;;obj.foo(); // obj 它产生的引用类型的值： 1234var fooReference = &#123; base: obj, referenceName: foo&#125;; 就近原则对象属性引用链中只有最后一层（最靠近调用函数）会影响调用位置。举例来说： 123456789101112function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo: foo &#125;;var obj1 = &#123; a: 2, obj2: obj2 &#125;;obj1.obj2.foo(); // 42 绑定丢失有一种情况我们需要考虑一下，就是进行传值的时候； 12345678var obj = &#123; foo: function() &#123; console.log(this); &#125;&#125;var bar = obj.foo;bar(); // window 我们可以看到 bar() 输出的值变了，因为在进行调用的时候, bar 生成了一个新的引用类型值： 1234var barReference = &#123; base: global, referenceName: bar&#125;; 难道这就没了吗？当然不！我们引出这个概念，必须得有注意事项啊！ 当我们把对象属性函数引用传递给函数或者是内置函数当做参数时，回想一下我们之前提到过的，它们会发生一个隐式的赋值传递，所以，这个时候就会发生绑定丢失。 123456789101112function bar(m) &#123; // 这里发生了一个隐式的赋值，m = obj.foo; m();&#125;var obj = &#123; foo: function() &#123; console.log(this); &#125;&#125;bar(obj.foo); // window call、apply调用 .call() 、 .apply() 调用比较类似，它们的第一个参数都是传递给 this 的值，不同的是， .call() 后面的参数可以是任意值， .apply()第二个参数为传入值组成的数组（只有两个参数）。 老板，再来一个栗子： 12345678function foo() &#123; console.log(this.a);&#125;var obj = &#123; a:2&#125;;foo.call(obj); // 2 通过 foo.call(...) ，我们可以在调用 foo() 时将 this 强制绑定到 obj 上。 bind调用 .bind() 是ECMAScript5中在函数原型上添加的方法，它将参数传递给this，并返回新的硬编码（函数内部显式绑定this）函数。 12345678910function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 1&#125;var bar = foo.bind(obj);bar(); // 1 API调用第三方库以及许多javascript中内置函数，会提供一个可选参数，成为“上下文”，确保你的回调函数使用指定的 this 。 For example： 123456789function foo(el) &#123; console.log(el, this.id);&#125;var obj = &#123; id: "awesome"&#125;;// 调用foo(..)时把this绑定到obj[1, 2, 3].forEach(foo, obj);// 1 awesome 2 awesome 3 awesome 构造函数大家都在说作为构造器调用的函数中的 this 都被设置为了新创建的对象，轻飘飘的一句话，我也能记住，可是究其原理呢？ 我们来看一下ECMA5中对new过程的解释吧：（主要是ECMA6整的太复杂了） Let ref be the result of evaluating MemberExpression. Let constructor be GetValue(ref). Let argList be the result of evaluating Arguments, producing an internal list of argument values. If Type(constructor) is not Object, throw a TypeError exception. If constructor does not implement the [[Construct]] internal method, throw a TypeError exception. Return the result of calling the [[Construct]] internal method on constructor, providing the list argList as the argument values. 这是针对有参构造函数的，如果是无参构造函数，则省去第三步。其大概意思是 ‘ new ‘ 后面必须跟一个对象并且该对象必须有一个名为 ‘ [[Construct]] ‘ 的内部方法，否则抛出异常。如果以上条件都成立，就执行 ‘ [[Construct]] ‘ 方法。 我们再来看看 [[Construct]] 内部方法是如何实现的： Let obj be a newly created native ECMAScript object. // 新建原生 js 对象 obj Set all the internal methods of obj as specified in 8.12. // 把 obj 的内置方法都设置好，它们都在8.12中罗列出来了 Set the [[Class]] internal property of obj to “Object”. //把 obj 的 [[Class]] 内部属性设置为 ‘object’ Set the [[Extensible]] internal property of obj to true. // 设置 [[Extensible]] 为 true Let proto be the value of calling the [[Get]] internal property of F with argument “prototype”. // 调用 [[get]] 方法得到构造函数 F 的 prototype 的值,赋给 proto If Type(proto) is Object, set the [[Prototype]] internal property of obj to proto. // 如果 proto 是一个对象，将 obj 的 [[Prototype]] 设置为proto If Type(proto) is not Object, set the [[Prototype]] internal property of obj to the standard built-in Object prototype object as described in 15.2.4. // 如果 proto 不是对象，则将 [[Prototype]] 设置为标准内置 Object 对象的 prototype 对象。 Let result be the result of calling the [[Call]] internal property of F, providing obj as the this value and providing the argument list passed into [[Construct]] as args. // 调用构造函数 F 的内部 [[Call]] 方法并赋值给 result ，调用时提供 obj 作为 this 的值，将传入参数作为入口参数 If Type(result) is Object then return result. // 如果 result 是对象，则返回 result 。 Return obj. // result 不是对象则返回 obj 。 间接引用当我们进行一些诸如赋值、 || 、 &amp;&amp; 之类的操作时，会不经意地创建一个“函数引用”。 1234567var obj = &#123; foo: function () &#123; console.log(this); &#125;&#125;;(obj.foo = obj.foo)(); // window 这里输出window的原因就是因为 (obj.foo = obj.foo) 中存在 = ， 它使得赋值前它右边的 obj.foo 调用了 getValue 方法， getValue 方法返回了 function 的引用，所以这里就等于独立函数调用了。 箭头函数ECMAScript6中新添了一种箭头函数，它无法与上面四种情况混用，它的 this 取决于外层函数调用时绑定的 this ，而且它一旦被绑定无法更改。 12345678910111213141516function foo() &#123; return (a) =&gt; &#123; console.log(this); &#125;&#125;var obj1 = &#123; a: 1&#125;;var obj2 = &#123; a: 2&#125;;var bar = foo.bind(obj1);var baz = bar.call(obj2);baz(); // 1 不是 2，因为一旦绑定则无法更改 this 这一篇真的写了有一天了，有了很多感想，很多自己以为会了的东西其实根本就没有懂，因为写着写着就会发现自己有很多特别细节性的东西不值得推敲，甚至会有冲突，然后再逼着自己去找资料，看ECMA规范，这两天提高了很多吧。这是个好事也不是个好事，下次应当在写博文之前就整个地梳理遍，这样子知识才能更系统的消化，不至于显得写博客仅仅是来发现自己的不足。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之执行上下文]]></title>
      <url>%2F2016%2F06%2F09%2FJavascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
      <content type="text"><![CDATA[当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。 如果你刚看《高程》，看到这句话估计会似是而非的理解。其实我当时也是，直到最近撸第二遍，也是偶然看到大叔的系列文章，有心研究了下，加上自己的理解，促成了这几篇博文。今天我们先来聊聊执行上下文与活动对象。 执行上下文执行上下文可能不太容易理解，其实它就是上面写到的执行环境，代码就是在相对应的执行环境中运行的。所以我们可以这样理解，每当调用一个函数，就会相应地为这个函数划出一块地，该函数所有的代码活动都被限制在这块地上。 好，这里我们可以引出两个问题：这块地是什么？只有函数调用才能创建EC吗？ 这块地是什么？当然就是内存了。无论是js还是其他代码，代码的运行所需空间都是由内存来分配的。内存分堆(heap)和栈(stack)，在这里，执行上下文组成了 执行上下文栈 来调控代码的进行，执行上下文栈的顶端就是正在使用的上下文。我们来用图示看一下： 123456789101112var a = 1, b = 2;function foo() &#123; a = 3; bar(); alert(a + b);&#125;function bar() &#123; b = 3;&#125;foo(); 当程序结束时，全局上下文出栈并销毁。 相信大家也注意到了上面出现了很多次的 全局上下文 ，它可以很好的回答我们的第二个问题：不是! 那么，问题就来了。。。 什么代码可以创建EC？ 全局代码 函数代码 Eval代码 全局代码全局代码就是 &lt;script&gt; 标签中的，或者是通过外部加载的js文件中的代码，它不包含任何函数体内的代码。全局代码创建的EC就是我们上文中所提的全局上下文，它是程序刚开始，代码尚未执行时就产生的上下文，它永远处在执行上下文栈的底部。 函数代码 function 函数中的代码段就是函数代码，它也不包括内部函数代码。 函数如果递归调用自身，每调用一次都会创建一个新的执行上下文。如果函数体内有 return ，执行到它的时候会立刻退出当前执行上下文。 Eval代码Eval代码和函数代码类似，执行到它的时候也会创建一个新的执行上下文。但不同的是，它有一个调用上下文（calling context），同样会压入ECStack。eval函数中如果进行变量、函数声明，将会体现到调用上下文中。 不过eval会使阅读性、安全性、性能下降，不建议大家使用。 变量对象代码执行的时候访问的变量都是从变量对象中取到的。 变量对象（Variable Object）其实是执行上下文的一个属性，执行上下文还有 this 和 作用域 属性。它们介绍起来篇幅很大，所以我把它放到了后面的文章。 变量对象分为两类：1.全局上下文变量对象2.函数上下文变量对象 全局上下文中的变量对象全局上下文变量对象就是全局对象。 全局对象本身包含很多属性如Math、String、Date、parseInt等等，大家不妨用 console.log(this) 在控制台中查看一下，还有，在全局作用域中声明的变量和函数也会成为它的属性。 当访问全局对象的属性时通常会忽略掉前缀，这是因为全局对象是不能通过名称直接访问的。不过我们依然可以通过全局上下文的this来访问全局对象，同样也可以递归引用自身。例如，DOM中的window。 函数上下文中的变量对象函数上下文中存在的是活动对象，它可以当做变量对象使用，其中包含变量、函数声明、形参、arguments。 我们来配合一个例子看一下： 12345678var a = 10; function foo(b) &#123; var c = 20; c += b;&#125;;foo(30) 对应的变量对象是： 123456789101112// 全局上下文的变量对象（不包含自带属性）VO(globalContext) = &#123; a: 10, foo: &lt;reference to function&gt;&#125;VO(foo functionContext) = &#123; // arguments其实是一个类数组对象，可以通过下标来访问实参，它同时包含callee、length、properties-indexes三个属性 arguments: &lt;ArgO&gt; b: 30, // 形参 c: 20 // 变量&#125; 我们想一个问题，变量对象是初始化时就是这样吗？其实不是这样，执行上下文中的代码分两个阶段，不同阶段值不同，这也是js的很重要的一个特性。 执行上下文的两个阶段我们透过这段代码在不同时期的变量对象看一下。 12345678function test(a, b) &#123; var c = 10; function d() &#123;&#125; var e = function _e() &#123;&#125;; (function x() &#123;&#125;);&#125; test(10); // call 进入执行上下文这个阶段处于代码执行之前，此时执行上下文的VO已经包含函数声明、形参、变量、arguments。其实这个阶段就是声明提升的阶段。 此时AO对象数据为： 类型 赋值与否 变量 undefined 函数声明 对函数的引用 形参 赋值 arguments 赋值 建议大家配合 Javascript深入浅出之声明与提升 中的 提升规则 一起看看。 对应变量对象： 12345678// 活动对象AO(test) = &#123; a: 10, b: undefined, c: undefined, d: &lt;reference to FunctionDeclaration "d"&gt; e: undefined&#125;; 代码执行此时AO对象数据为： 类型 赋值与否 变量 赋值 函数声明 对函数的引用 形参 赋值 arguments 赋值 在这个阶段中，AO被改成了 12AO['c'] = 10;AO['e'] = &lt;reference to FunctionExpression "_e"&gt;; 到了这里，相信大家都对函数调用阶段有个很多本质的理解，配合本文也可以更好地理解声明提升，也为后面理解闭包打好基础。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript深入浅出之声明与提升]]></title>
      <url>%2F2016%2F06%2F07%2FJavascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E4%B9%8B%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%8F%90%E5%8D%87%2F</url>
      <content type="text"><![CDATA[var 声明了一个变量，同时可以初始化该变量。 1var name1 [= value1 [, varname2 [, varname3 ... [, varnameN]]]]; 单 var 模式在函数的顶部使用一个单独的 var 语句是非常推荐的一种模式，它有如下一些好处： 在同一个位置可以查找到函数所需的所有变量 避免当在变量声明之前使用这个变量时产生的逻辑错误 提醒你不要忘记声明变量，顺便减少潜在的全局变量 代码量更少（输入更少且更易做代码优化） 单 var 模式看起来像这样： 123456789function func() &#123; var a = 1, b = 2, sum = a + b, myobject = &#123;&#125;, i, j; // function body...&#125; 单 var 衍生的误区123456function test() &#123; var param1 = param2 = 2;&#125;test();console.log(param1); // Uncaught ReferenceErrorconsole.log(param2); // 2 可能有人就会疑惑，为什么这里的 param1 是局部变量，而 param2 却是全局变量呢？ = 运算从右向左合并，上一段代码其实是这样运行的： 12345function test() &#123; var param1; param2 = 2; // 全局变量 （严格模式下会抛出错误） param1 = param2; // 局部变量&#125; 未声明变量 给一个非声明变量赋值会隐式创建一个全局变量（全局object的一个属性）。 这句话大家应该都很熟悉，即便你是刚入门的新手；但也有人不完全赞同这句话，他们感觉它不符合ECMAScript的基本变量的定义，它只算是全局属性；那我们就来细细探讨一下声明变量与未声明变量的区别： 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。 声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。 12345console.log(a); // Uncaught ReferenceErrorconsole.log(b); // 2 a = 1;var b = 2; 声明变量是它所在上下文环境的不可配置属性（non-configurable property），非声明变量是可配置的（例如非声明变量可以被删除）。 1234567var a =1;b = 1;console.log(delete a); // falseconsole.log(delete b); // trueconsole.log(this.a); // 1console.log(this.b); // Uncaught ReferenceError 所以，使用未经声明的变量会带来很多潜在的代码危险，也建议大家尽量不要使用；而且严格模式下会抛出错误。 提升先看一段代码： 123a = 2;var a;console.log(a); 很多人可能认为这段代码输出的是 undefined ；因为开始 a 被初始化为2，接着又被重新声明并被默认赋值为 undefined 。 再看下一段代码： 12console.log(a);var a = 2; 这段代码可能又会有人认为它要报错了，因为在执行 console.log 前 a 尚未声明。 其实刚才两段代码会分别输出 2 和 undefined ，那又是为什么呢？ 在引擎解释代码之前，编译器会预先对其进行编译，编译工作的其中一块就是将所有的声明预先进行处理。 当你看到 var a = 2 时，你以为直接就是将 2 赋值给 a ，其实它会分成两个阶段进行，第一阶段就是进行 var a 编译（在当前作用域代码执行前）； 第二阶段就是执行 a = 2（等待js执行到代码所在行）； 所以第一段代码真实的执行顺序是这样的： 123var a;a = 2;console.log(a); 第一阶段就是编译，第二阶段是执行；这就是 变量提升。类似地，第二段是这样处理的： 123var a;console.log(a);a = 2; 提升规则我们先来看看会进行提升的都有哪些，稍后再进行解释： 函数声明，函数声明优先级最高，忽略重复的变量和形参声明 形参，比变量声明优先，忽略重复的变量声明 变量声明 ※ 提升只会在其自身执行上下文中进行。什么？不知道执行上下文？下篇文章会介绍！ 形参12345function foo(a) &#123; console.log(a);&#125;foo(2); // 2 上面 foo 在执行时，会先进行 隐式的声明赋值 操作 var a = 2 ，然后在执行函数中的代码段；怎么证明呢？我们来改一下上面的代码： 1234567function foo(a) &#123; a = 3; console.log(a);&#125;foo(2); // 3console.log(a); // Uncaught ReferenceError 如果它没有这个隐式的声明，这里的 a 应该是全局变量（属性），函数体外就可以访问到。 因为它的这一特性,我之前一直以为形参和变量一模一样，只声明不赋值（其实默认赋值undefined），只不过执行时它的代码在函数体所有代码之上，后来发现其实不然。 形参声明的同时会接受实参的赋值，如果没有对应实参，赋值为undefined 。 123456function foo(a) &#123; console.log(a); function a() &#123;&#125;; &#125;foo(2); // function a() &#123;&#125; 如果按照我原先的理解，上面这段代码，在所有声明提升之后，执行 console.log(a); 之前会有一个 a = 2 的赋值，最后输出的就不会是 function 而是 2 。所以很明显，形参声明的同时就已经接收了实参的赋值，但优先级不高被函数声明覆盖了。 函数声明注意我们这里写的是 函数声明 ，不包含 函数表达式 。 12foo();function foo() &#123;&#125; 这一段代码可以正常执行，因为 foo 函数的声明已经被提升了。 1234foo(); // Uncaught ReferenceErrora(); // Uncaught TypeErrorvar a = function foo() &#123;&#125;;foo(); // Uncaught ReferenceError 上面这段代码可以看出来函数表达式不会让函数得到提升。而 a() 为什么会提示Uncaught TypeError呢，因为上面代码实际是这样处理的： 12345var a;foo();a();a = function foo() &#123;&#125;;foo(); // Uncaught ReferenceError 执行到 a() 的时候 a 还只是被默认赋值为 undefined ，并不包含对函数的引用。还要提到的一点就是，函数 foo 只能在其自身作用域内被发现。 函数声明比变量声明优先，忽略重复的变量声明 123456console.log(a); // function a() &#123;&#125; var a = 2;function a() &#123;&#125; console.log(a); // 2 上面第一个 console.log(a); 会输出 function a() {} 是因为函数声明优先，并且忽略了后面同名变量的声明。第二个 console.log(a); 输出 2 是因为执行代码时不会忽略初始化操作。代码的实际处理情况是： 12345678function a() &#123;&#125;// var a; 被忽略了 console.log(a); // function a() &#123;&#125;a = 2;console.log(a); // 2 如果是同名函数的声明则会对其进行覆盖，所以js没有函数重载。 练习123456var y = 1, x = y = typeof x;console.log(x);求上面代码段输出值; 答案1234567var y; // undefinedvar x; // undefinedy = 1;y = undefined;x = undefined;console.log(x); // undefined]]></content>
    </entry>

    
  
  
</search>
